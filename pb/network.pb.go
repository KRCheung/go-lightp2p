// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: network.proto

package pb

import (
	fmt "fmt"
	github_com_golang_protobuf_proto "github.com/golang/protobuf/proto"
	proto "github.com/golang/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type Message_Type int32

const (
	Message_FETCH_DATA              Message_Type = 1
	Message_FETCH_DATA_REQ          Message_Type = 2
	Message_FETCH_DATA_ACK          Message_Type = 3
	Message_REQUEST_CHECK_MODEL     Message_Type = 4
	Message_REQUEST_CHECK_MODEL_ACK Message_Type = 5
	Message_CHECK_MODEL             Message_Type = 6
	Message_CHECK_MODEL_ACK         Message_Type = 7
	Message_REQUEST_RUN_MODEL       Message_Type = 8
	Message_REQUEST_RUN_MODEL_ACK   Message_Type = 9
	Message_RESPONSE_RUN_MODEL      Message_Type = 10
	Message_RESPONSE_RUN_MODEL_ACK  Message_Type = 11
	Message_QUERY_RES_REQ           Message_Type = 12
	Message_QUERY_RES_ACK           Message_Type = 13
	Message_CANCEL_TASK             Message_Type = 14
	Message_CANCEL_TASK_ACK         Message_Type = 15
	Message_REQUEST_CALL            Message_Type = 16
	Message_REQUEST_CALL_ACK        Message_Type = 17
	Message_RESPONSE_CALL           Message_Type = 18
	Message_RESPONSE_CALL_ACK       Message_Type = 19
	Message_NETWORK_HANDSHAKE_PING  Message_Type = 20
	Message_NETWORK_HANDSHAKE_PONG  Message_Type = 21
	Message_FETCH_CLUSTER_NODES     Message_Type = 22
	Message_FETCH_CLUSTER_NODES_RES Message_Type = 23
	// cert verify message type
	Message_CERT_VERIFY              Message_Type = 24
	Message_CLUSTER_FILES_ADD        Message_Type = 25
	Message_CLUSTER_FILES_ADD_ACK    Message_Type = 26
	Message_CLUSTER_FILES_TAKE       Message_Type = 27
	Message_CLUSTER_FILES_TAKE_ACK   Message_Type = 28
	Message_CLUSTER_FILES_DELETE     Message_Type = 29
	Message_CLUSTER_FILES_DELETE_ACK Message_Type = 30
	//Federated Computation
	Message_FederatedComputation_Request              Message_Type = 31
	Message_FederatedComputation_Response             Message_Type = 32
	Message_FederatedComputation_Intermediate_Message Message_Type = 33
)

var Message_Type_name = map[int32]string{
	1:  "FETCH_DATA",
	2:  "FETCH_DATA_REQ",
	3:  "FETCH_DATA_ACK",
	4:  "REQUEST_CHECK_MODEL",
	5:  "REQUEST_CHECK_MODEL_ACK",
	6:  "CHECK_MODEL",
	7:  "CHECK_MODEL_ACK",
	8:  "REQUEST_RUN_MODEL",
	9:  "REQUEST_RUN_MODEL_ACK",
	10: "RESPONSE_RUN_MODEL",
	11: "RESPONSE_RUN_MODEL_ACK",
	12: "QUERY_RES_REQ",
	13: "QUERY_RES_ACK",
	14: "CANCEL_TASK",
	15: "CANCEL_TASK_ACK",
	16: "REQUEST_CALL",
	17: "REQUEST_CALL_ACK",
	18: "RESPONSE_CALL",
	19: "RESPONSE_CALL_ACK",
	20: "NETWORK_HANDSHAKE_PING",
	21: "NETWORK_HANDSHAKE_PONG",
	22: "FETCH_CLUSTER_NODES",
	23: "FETCH_CLUSTER_NODES_RES",
	24: "CERT_VERIFY",
	25: "CLUSTER_FILES_ADD",
	26: "CLUSTER_FILES_ADD_ACK",
	27: "CLUSTER_FILES_TAKE",
	28: "CLUSTER_FILES_TAKE_ACK",
	29: "CLUSTER_FILES_DELETE",
	30: "CLUSTER_FILES_DELETE_ACK",
	31: "FederatedComputation_Request",
	32: "FederatedComputation_Response",
	33: "FederatedComputation_Intermediate_Message",
}

var Message_Type_value = map[string]int32{
	"FETCH_DATA":                                1,
	"FETCH_DATA_REQ":                            2,
	"FETCH_DATA_ACK":                            3,
	"REQUEST_CHECK_MODEL":                       4,
	"REQUEST_CHECK_MODEL_ACK":                   5,
	"CHECK_MODEL":                               6,
	"CHECK_MODEL_ACK":                           7,
	"REQUEST_RUN_MODEL":                         8,
	"REQUEST_RUN_MODEL_ACK":                     9,
	"RESPONSE_RUN_MODEL":                        10,
	"RESPONSE_RUN_MODEL_ACK":                    11,
	"QUERY_RES_REQ":                             12,
	"QUERY_RES_ACK":                             13,
	"CANCEL_TASK":                               14,
	"CANCEL_TASK_ACK":                           15,
	"REQUEST_CALL":                              16,
	"REQUEST_CALL_ACK":                          17,
	"RESPONSE_CALL":                             18,
	"RESPONSE_CALL_ACK":                         19,
	"NETWORK_HANDSHAKE_PING":                    20,
	"NETWORK_HANDSHAKE_PONG":                    21,
	"FETCH_CLUSTER_NODES":                       22,
	"FETCH_CLUSTER_NODES_RES":                   23,
	"CERT_VERIFY":                               24,
	"CLUSTER_FILES_ADD":                         25,
	"CLUSTER_FILES_ADD_ACK":                     26,
	"CLUSTER_FILES_TAKE":                        27,
	"CLUSTER_FILES_TAKE_ACK":                    28,
	"CLUSTER_FILES_DELETE":                      29,
	"CLUSTER_FILES_DELETE_ACK":                  30,
	"FederatedComputation_Request":              31,
	"FederatedComputation_Response":             32,
	"FederatedComputation_Intermediate_Message": 33,
}

func (x Message_Type) Enum() *Message_Type {
	p := new(Message_Type)
	*p = x
	return p
}

func (x Message_Type) String() string {
	return proto.EnumName(Message_Type_name, int32(x))
}

func (x *Message_Type) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Message_Type_value, data, "Message_Type")
	if err != nil {
		return err
	}
	*x = Message_Type(value)
	return nil
}

func (Message_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_8571034d60397816, []int{2, 0}
}

type FCRequest_FCType int32

const (
	FCRequest_NORMAL_INVOKE FCRequest_FCType = 1
	FCRequest_PSA_INVOKE    FCRequest_FCType = 2
	FCRequest_PSI_INVOKE    FCRequest_FCType = 3
)

var FCRequest_FCType_name = map[int32]string{
	1: "NORMAL_INVOKE",
	2: "PSA_INVOKE",
	3: "PSI_INVOKE",
}

var FCRequest_FCType_value = map[string]int32{
	"NORMAL_INVOKE": 1,
	"PSA_INVOKE":    2,
	"PSI_INVOKE":    3,
}

func (x FCRequest_FCType) Enum() *FCRequest_FCType {
	p := new(FCRequest_FCType)
	*p = x
	return p
}

func (x FCRequest_FCType) String() string {
	return proto.EnumName(FCRequest_FCType_name, int32(x))
}

func (x *FCRequest_FCType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(FCRequest_FCType_value, data, "FCRequest_FCType")
	if err != nil {
		return err
	}
	*x = FCRequest_FCType(value)
	return nil
}

func (FCRequest_FCType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_8571034d60397816, []int{30, 0}
}

type PSAInvokeExternal_PSAType int32

const (
	PSAInvokeExternal_ADD PSAInvokeExternal_PSAType = 1
	PSAInvokeExternal_SUB PSAInvokeExternal_PSAType = 2
)

var PSAInvokeExternal_PSAType_name = map[int32]string{
	1: "ADD",
	2: "SUB",
}

var PSAInvokeExternal_PSAType_value = map[string]int32{
	"ADD": 1,
	"SUB": 2,
}

func (x PSAInvokeExternal_PSAType) Enum() *PSAInvokeExternal_PSAType {
	p := new(PSAInvokeExternal_PSAType)
	*p = x
	return p
}

func (x PSAInvokeExternal_PSAType) String() string {
	return proto.EnumName(PSAInvokeExternal_PSAType_name, int32(x))
}

func (x *PSAInvokeExternal_PSAType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(PSAInvokeExternal_PSAType_value, data, "PSAInvokeExternal_PSAType")
	if err != nil {
		return err
	}
	*x = PSAInvokeExternal_PSAType(value)
	return nil
}

func (PSAInvokeExternal_PSAType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_8571034d60397816, []int{31, 0}
}

type FCIntermediateMessage_Type int32

const (
	FCIntermediateMessage_KEY_REQUEST                FCIntermediateMessage_Type = 1
	FCIntermediateMessage_KEY_RESPONSE               FCIntermediateMessage_Type = 2
	FCIntermediateMessage_KEY_UPDATE                 FCIntermediateMessage_Type = 3
	FCIntermediateMessage_KEY_UPDATE_ACK             FCIntermediateMessage_Type = 4
	FCIntermediateMessage_KEY_UPDATE_FINISH          FCIntermediateMessage_Type = 5
	FCIntermediateMessage_PSI_INIT_FINISH            FCIntermediateMessage_Type = 6
	FCIntermediateMessage_PSI_INIT_FINISH_ACK        FCIntermediateMessage_Type = 7
	FCIntermediateMessage_PSI_MASK_REQUEST           FCIntermediateMessage_Type = 8
	FCIntermediateMessage_PSI_MASK_RESPONSE_INIT     FCIntermediateMessage_Type = 9
	FCIntermediateMessage_PSI_MASK_RESPONSE_INIT_ACK FCIntermediateMessage_Type = 10
	FCIntermediateMessage_PSI_MASK_RESPONSE          FCIntermediateMessage_Type = 11
)

var FCIntermediateMessage_Type_name = map[int32]string{
	1:  "KEY_REQUEST",
	2:  "KEY_RESPONSE",
	3:  "KEY_UPDATE",
	4:  "KEY_UPDATE_ACK",
	5:  "KEY_UPDATE_FINISH",
	6:  "PSI_INIT_FINISH",
	7:  "PSI_INIT_FINISH_ACK",
	8:  "PSI_MASK_REQUEST",
	9:  "PSI_MASK_RESPONSE_INIT",
	10: "PSI_MASK_RESPONSE_INIT_ACK",
	11: "PSI_MASK_RESPONSE",
}

var FCIntermediateMessage_Type_value = map[string]int32{
	"KEY_REQUEST":                1,
	"KEY_RESPONSE":               2,
	"KEY_UPDATE":                 3,
	"KEY_UPDATE_ACK":             4,
	"KEY_UPDATE_FINISH":          5,
	"PSI_INIT_FINISH":            6,
	"PSI_INIT_FINISH_ACK":        7,
	"PSI_MASK_REQUEST":           8,
	"PSI_MASK_RESPONSE_INIT":     9,
	"PSI_MASK_RESPONSE_INIT_ACK": 10,
	"PSI_MASK_RESPONSE":          11,
}

func (x FCIntermediateMessage_Type) Enum() *FCIntermediateMessage_Type {
	p := new(FCIntermediateMessage_Type)
	*p = x
	return p
}

func (x FCIntermediateMessage_Type) String() string {
	return proto.EnumName(FCIntermediateMessage_Type_name, int32(x))
}

func (x *FCIntermediateMessage_Type) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(FCIntermediateMessage_Type_value, data, "FCIntermediateMessage_Type")
	if err != nil {
		return err
	}
	*x = FCIntermediateMessage_Type(value)
	return nil
}

func (FCIntermediateMessage_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_8571034d60397816, []int{35, 0}
}

// FetchData request fetch file or invoke restful or model
type FetchData struct {
	AppKey               *string  `protobuf:"bytes,1,req,name=appKey" json:"appKey,omitempty"`
	Args                 []byte   `protobuf:"bytes,2,req,name=args" json:"args,omitempty"`
	Function             *string  `protobuf:"bytes,3,req,name=function" json:"function,omitempty"`
	NRet                 *uint32  `protobuf:"varint,4,req,name=nRet" json:"nRet,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FetchData) Reset()         { *m = FetchData{} }
func (m *FetchData) String() string { return proto.CompactTextString(m) }
func (*FetchData) ProtoMessage()    {}
func (*FetchData) Descriptor() ([]byte, []int) {
	return fileDescriptor_8571034d60397816, []int{0}
}
func (m *FetchData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FetchData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FetchData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FetchData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FetchData.Merge(m, src)
}
func (m *FetchData) XXX_Size() int {
	return m.Size()
}
func (m *FetchData) XXX_DiscardUnknown() {
	xxx_messageInfo_FetchData.DiscardUnknown(m)
}

var xxx_messageInfo_FetchData proto.InternalMessageInfo

func (m *FetchData) GetAppKey() string {
	if m != nil && m.AppKey != nil {
		return *m.AppKey
	}
	return ""
}

func (m *FetchData) GetArgs() []byte {
	if m != nil {
		return m.Args
	}
	return nil
}

func (m *FetchData) GetFunction() string {
	if m != nil && m.Function != nil {
		return *m.Function
	}
	return ""
}

func (m *FetchData) GetNRet() uint32 {
	if m != nil && m.NRet != nil {
		return *m.NRet
	}
	return 0
}

// FetchDataACK is FetchData ACK
type FetchDataACK struct {
	Did                  *string  `protobuf:"bytes,1,req,name=did" json:"did,omitempty"`
	Data                 []byte   `protobuf:"bytes,2,opt,name=data" json:"data,omitempty"`
	Length               *uint64  `protobuf:"varint,3,opt,name=length" json:"length,omitempty"`
	Error                *string  `protobuf:"bytes,4,opt,name=error" json:"error,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FetchDataACK) Reset()         { *m = FetchDataACK{} }
func (m *FetchDataACK) String() string { return proto.CompactTextString(m) }
func (*FetchDataACK) ProtoMessage()    {}
func (*FetchDataACK) Descriptor() ([]byte, []int) {
	return fileDescriptor_8571034d60397816, []int{1}
}
func (m *FetchDataACK) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FetchDataACK) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FetchDataACK.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FetchDataACK) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FetchDataACK.Merge(m, src)
}
func (m *FetchDataACK) XXX_Size() int {
	return m.Size()
}
func (m *FetchDataACK) XXX_DiscardUnknown() {
	xxx_messageInfo_FetchDataACK.DiscardUnknown(m)
}

var xxx_messageInfo_FetchDataACK proto.InternalMessageInfo

func (m *FetchDataACK) GetDid() string {
	if m != nil && m.Did != nil {
		return *m.Did
	}
	return ""
}

func (m *FetchDataACK) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *FetchDataACK) GetLength() uint64 {
	if m != nil && m.Length != nil {
		return *m.Length
	}
	return 0
}

func (m *FetchDataACK) GetError() string {
	if m != nil && m.Error != nil {
		return *m.Error
	}
	return ""
}

// Message defines all protobuf message struct
// Type is message type
// Body is message content, maybe is marshaled by protobuf
// Signature is message signature, this is optional field
type Message struct {
	Type                 *Message_Type `protobuf:"varint,1,req,name=type,enum=pb.Message_Type" json:"type,omitempty"`
	Body                 []byte        `protobuf:"bytes,2,req,name=body" json:"body,omitempty"`
	Signature            []byte        `protobuf:"bytes,3,opt,name=signature" json:"signature,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *Message) Reset()         { *m = Message{} }
func (m *Message) String() string { return proto.CompactTextString(m) }
func (*Message) ProtoMessage()    {}
func (*Message) Descriptor() ([]byte, []int) {
	return fileDescriptor_8571034d60397816, []int{2}
}
func (m *Message) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Message) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Message.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Message) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Message.Merge(m, src)
}
func (m *Message) XXX_Size() int {
	return m.Size()
}
func (m *Message) XXX_DiscardUnknown() {
	xxx_messageInfo_Message.DiscardUnknown(m)
}

var xxx_messageInfo_Message proto.InternalMessageInfo

func (m *Message) GetType() Message_Type {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return Message_FETCH_DATA
}

func (m *Message) GetBody() []byte {
	if m != nil {
		return m.Body
	}
	return nil
}

func (m *Message) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

// RemoteRequest is remote query request
type RemoteRequest struct {
	AppKey               *string  `protobuf:"bytes,1,req,name=appKey" json:"appKey,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RemoteRequest) Reset()         { *m = RemoteRequest{} }
func (m *RemoteRequest) String() string { return proto.CompactTextString(m) }
func (*RemoteRequest) ProtoMessage()    {}
func (*RemoteRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_8571034d60397816, []int{3}
}
func (m *RemoteRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RemoteRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RemoteRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RemoteRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RemoteRequest.Merge(m, src)
}
func (m *RemoteRequest) XXX_Size() int {
	return m.Size()
}
func (m *RemoteRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RemoteRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RemoteRequest proto.InternalMessageInfo

func (m *RemoteRequest) GetAppKey() string {
	if m != nil && m.AppKey != nil {
		return *m.AppKey
	}
	return ""
}

// RemoteResponse is remote query response
type RemoteResponse struct {
	Res                  []byte   `protobuf:"bytes,2,opt,name=res" json:"res,omitempty"`
	Error                *string  `protobuf:"bytes,3,opt,name=error" json:"error,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RemoteResponse) Reset()         { *m = RemoteResponse{} }
func (m *RemoteResponse) String() string { return proto.CompactTextString(m) }
func (*RemoteResponse) ProtoMessage()    {}
func (*RemoteResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_8571034d60397816, []int{4}
}
func (m *RemoteResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RemoteResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RemoteResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RemoteResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RemoteResponse.Merge(m, src)
}
func (m *RemoteResponse) XXX_Size() int {
	return m.Size()
}
func (m *RemoteResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RemoteResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RemoteResponse proto.InternalMessageInfo

func (m *RemoteResponse) GetRes() []byte {
	if m != nil {
		return m.Res
	}
	return nil
}

func (m *RemoteResponse) GetError() string {
	if m != nil && m.Error != nil {
		return *m.Error
	}
	return ""
}

// RequestCheckModel request check model
type RequestCheckModel struct {
	TaskHash             *string  `protobuf:"bytes,1,req,name=taskHash" json:"taskHash,omitempty"`
	Name                 *string  `protobuf:"bytes,2,req,name=name" json:"name,omitempty"`
	Time                 *int64   `protobuf:"varint,3,req,name=time" json:"time,omitempty"`
	Description          *string  `protobuf:"bytes,4,req,name=description" json:"description,omitempty"`
	Creator              *string  `protobuf:"bytes,5,req,name=creator" json:"creator,omitempty"`
	Model                []byte   `protobuf:"bytes,6,req,name=model" json:"model,omitempty"`
	ModelName            []byte   `protobuf:"bytes,7,req,name=modelName" json:"modelName,omitempty"`
	AppKey               *string  `protobuf:"bytes,8,req,name=appKey" json:"appKey,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RequestCheckModel) Reset()         { *m = RequestCheckModel{} }
func (m *RequestCheckModel) String() string { return proto.CompactTextString(m) }
func (*RequestCheckModel) ProtoMessage()    {}
func (*RequestCheckModel) Descriptor() ([]byte, []int) {
	return fileDescriptor_8571034d60397816, []int{5}
}
func (m *RequestCheckModel) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RequestCheckModel) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RequestCheckModel.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RequestCheckModel) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RequestCheckModel.Merge(m, src)
}
func (m *RequestCheckModel) XXX_Size() int {
	return m.Size()
}
func (m *RequestCheckModel) XXX_DiscardUnknown() {
	xxx_messageInfo_RequestCheckModel.DiscardUnknown(m)
}

var xxx_messageInfo_RequestCheckModel proto.InternalMessageInfo

func (m *RequestCheckModel) GetTaskHash() string {
	if m != nil && m.TaskHash != nil {
		return *m.TaskHash
	}
	return ""
}

func (m *RequestCheckModel) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *RequestCheckModel) GetTime() int64 {
	if m != nil && m.Time != nil {
		return *m.Time
	}
	return 0
}

func (m *RequestCheckModel) GetDescription() string {
	if m != nil && m.Description != nil {
		return *m.Description
	}
	return ""
}

func (m *RequestCheckModel) GetCreator() string {
	if m != nil && m.Creator != nil {
		return *m.Creator
	}
	return ""
}

func (m *RequestCheckModel) GetModel() []byte {
	if m != nil {
		return m.Model
	}
	return nil
}

func (m *RequestCheckModel) GetModelName() []byte {
	if m != nil {
		return m.ModelName
	}
	return nil
}

func (m *RequestCheckModel) GetAppKey() string {
	if m != nil && m.AppKey != nil {
		return *m.AppKey
	}
	return ""
}

// RequestCheckModelACK is ACK of RequestCheckModel
type RequestCheckModelACK struct {
	Code                 *uint32  `protobuf:"varint,1,req,name=code" json:"code,omitempty"`
	Err                  *string  `protobuf:"bytes,2,opt,name=err" json:"err,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RequestCheckModelACK) Reset()         { *m = RequestCheckModelACK{} }
func (m *RequestCheckModelACK) String() string { return proto.CompactTextString(m) }
func (*RequestCheckModelACK) ProtoMessage()    {}
func (*RequestCheckModelACK) Descriptor() ([]byte, []int) {
	return fileDescriptor_8571034d60397816, []int{6}
}
func (m *RequestCheckModelACK) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RequestCheckModelACK) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RequestCheckModelACK.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RequestCheckModelACK) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RequestCheckModelACK.Merge(m, src)
}
func (m *RequestCheckModelACK) XXX_Size() int {
	return m.Size()
}
func (m *RequestCheckModelACK) XXX_DiscardUnknown() {
	xxx_messageInfo_RequestCheckModelACK.DiscardUnknown(m)
}

var xxx_messageInfo_RequestCheckModelACK proto.InternalMessageInfo

func (m *RequestCheckModelACK) GetCode() uint32 {
	if m != nil && m.Code != nil {
		return *m.Code
	}
	return 0
}

func (m *RequestCheckModelACK) GetErr() string {
	if m != nil && m.Err != nil {
		return *m.Err
	}
	return ""
}

// CheckModel is check model result
type CheckModel struct {
	TaskHash             *string  `protobuf:"bytes,1,req,name=taskHash" json:"taskHash,omitempty"`
	ModelHash            *string  `protobuf:"bytes,2,req,name=modelHash" json:"modelHash,omitempty"`
	Code                 *uint32  `protobuf:"varint,3,req,name=code" json:"code,omitempty"`
	Msg                  *string  `protobuf:"bytes,4,opt,name=msg" json:"msg,omitempty"`
	Err                  *string  `protobuf:"bytes,5,opt,name=err" json:"err,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CheckModel) Reset()         { *m = CheckModel{} }
func (m *CheckModel) String() string { return proto.CompactTextString(m) }
func (*CheckModel) ProtoMessage()    {}
func (*CheckModel) Descriptor() ([]byte, []int) {
	return fileDescriptor_8571034d60397816, []int{7}
}
func (m *CheckModel) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CheckModel) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CheckModel.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CheckModel) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CheckModel.Merge(m, src)
}
func (m *CheckModel) XXX_Size() int {
	return m.Size()
}
func (m *CheckModel) XXX_DiscardUnknown() {
	xxx_messageInfo_CheckModel.DiscardUnknown(m)
}

var xxx_messageInfo_CheckModel proto.InternalMessageInfo

func (m *CheckModel) GetTaskHash() string {
	if m != nil && m.TaskHash != nil {
		return *m.TaskHash
	}
	return ""
}

func (m *CheckModel) GetModelHash() string {
	if m != nil && m.ModelHash != nil {
		return *m.ModelHash
	}
	return ""
}

func (m *CheckModel) GetCode() uint32 {
	if m != nil && m.Code != nil {
		return *m.Code
	}
	return 0
}

func (m *CheckModel) GetMsg() string {
	if m != nil && m.Msg != nil {
		return *m.Msg
	}
	return ""
}

func (m *CheckModel) GetErr() string {
	if m != nil && m.Err != nil {
		return *m.Err
	}
	return ""
}

// CheckModelACK is ACK of CheckModel
type CheckModelACK struct {
	Code                 *uint32  `protobuf:"varint,1,req,name=code" json:"code,omitempty"`
	Err                  *string  `protobuf:"bytes,2,opt,name=err" json:"err,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CheckModelACK) Reset()         { *m = CheckModelACK{} }
func (m *CheckModelACK) String() string { return proto.CompactTextString(m) }
func (*CheckModelACK) ProtoMessage()    {}
func (*CheckModelACK) Descriptor() ([]byte, []int) {
	return fileDescriptor_8571034d60397816, []int{8}
}
func (m *CheckModelACK) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CheckModelACK) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CheckModelACK.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CheckModelACK) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CheckModelACK.Merge(m, src)
}
func (m *CheckModelACK) XXX_Size() int {
	return m.Size()
}
func (m *CheckModelACK) XXX_DiscardUnknown() {
	xxx_messageInfo_CheckModelACK.DiscardUnknown(m)
}

var xxx_messageInfo_CheckModelACK proto.InternalMessageInfo

func (m *CheckModelACK) GetCode() uint32 {
	if m != nil && m.Code != nil {
		return *m.Code
	}
	return 0
}

func (m *CheckModelACK) GetErr() string {
	if m != nil && m.Err != nil {
		return *m.Err
	}
	return ""
}

// CancelTask means canceling the task
type CancelTask struct {
	TaskHash             *string  `protobuf:"bytes,1,req,name=taskHash" json:"taskHash,omitempty"`
	AppKey               *string  `protobuf:"bytes,2,req,name=appKey" json:"appKey,omitempty"`
	ModelHash            *string  `protobuf:"bytes,3,opt,name=modelHash" json:"modelHash,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CancelTask) Reset()         { *m = CancelTask{} }
func (m *CancelTask) String() string { return proto.CompactTextString(m) }
func (*CancelTask) ProtoMessage()    {}
func (*CancelTask) Descriptor() ([]byte, []int) {
	return fileDescriptor_8571034d60397816, []int{9}
}
func (m *CancelTask) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CancelTask) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CancelTask.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CancelTask) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CancelTask.Merge(m, src)
}
func (m *CancelTask) XXX_Size() int {
	return m.Size()
}
func (m *CancelTask) XXX_DiscardUnknown() {
	xxx_messageInfo_CancelTask.DiscardUnknown(m)
}

var xxx_messageInfo_CancelTask proto.InternalMessageInfo

func (m *CancelTask) GetTaskHash() string {
	if m != nil && m.TaskHash != nil {
		return *m.TaskHash
	}
	return ""
}

func (m *CancelTask) GetAppKey() string {
	if m != nil && m.AppKey != nil {
		return *m.AppKey
	}
	return ""
}

func (m *CancelTask) GetModelHash() string {
	if m != nil && m.ModelHash != nil {
		return *m.ModelHash
	}
	return ""
}

// CancelTaskACK is ACK of CancelTask
type CancelTaskACK struct {
	Code                 *uint32  `protobuf:"varint,1,req,name=code" json:"code,omitempty"`
	Err                  *string  `protobuf:"bytes,2,opt,name=err" json:"err,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CancelTaskACK) Reset()         { *m = CancelTaskACK{} }
func (m *CancelTaskACK) String() string { return proto.CompactTextString(m) }
func (*CancelTaskACK) ProtoMessage()    {}
func (*CancelTaskACK) Descriptor() ([]byte, []int) {
	return fileDescriptor_8571034d60397816, []int{10}
}
func (m *CancelTaskACK) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CancelTaskACK) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CancelTaskACK.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CancelTaskACK) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CancelTaskACK.Merge(m, src)
}
func (m *CancelTaskACK) XXX_Size() int {
	return m.Size()
}
func (m *CancelTaskACK) XXX_DiscardUnknown() {
	xxx_messageInfo_CancelTaskACK.DiscardUnknown(m)
}

var xxx_messageInfo_CancelTaskACK proto.InternalMessageInfo

func (m *CancelTaskACK) GetCode() uint32 {
	if m != nil && m.Code != nil {
		return *m.Code
	}
	return 0
}

func (m *CancelTaskACK) GetErr() string {
	if m != nil && m.Err != nil {
		return *m.Err
	}
	return ""
}

// RequestRunModel request run data source model
type RequestRunModel struct {
	TaskHash             *string  `protobuf:"bytes,1,req,name=taskHash" json:"taskHash,omitempty"`
	ModelHash            *string  `protobuf:"bytes,2,req,name=modelHash" json:"modelHash,omitempty"`
	Args                 []byte   `protobuf:"bytes,3,req,name=args" json:"args,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RequestRunModel) Reset()         { *m = RequestRunModel{} }
func (m *RequestRunModel) String() string { return proto.CompactTextString(m) }
func (*RequestRunModel) ProtoMessage()    {}
func (*RequestRunModel) Descriptor() ([]byte, []int) {
	return fileDescriptor_8571034d60397816, []int{11}
}
func (m *RequestRunModel) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RequestRunModel) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RequestRunModel.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RequestRunModel) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RequestRunModel.Merge(m, src)
}
func (m *RequestRunModel) XXX_Size() int {
	return m.Size()
}
func (m *RequestRunModel) XXX_DiscardUnknown() {
	xxx_messageInfo_RequestRunModel.DiscardUnknown(m)
}

var xxx_messageInfo_RequestRunModel proto.InternalMessageInfo

func (m *RequestRunModel) GetTaskHash() string {
	if m != nil && m.TaskHash != nil {
		return *m.TaskHash
	}
	return ""
}

func (m *RequestRunModel) GetModelHash() string {
	if m != nil && m.ModelHash != nil {
		return *m.ModelHash
	}
	return ""
}

func (m *RequestRunModel) GetArgs() []byte {
	if m != nil {
		return m.Args
	}
	return nil
}

// RequestRunModelACK is ACK of RequestRunModel
type RequestRunModelACK struct {
	Code                 *uint32  `protobuf:"varint,1,req,name=code" json:"code,omitempty"`
	Err                  *string  `protobuf:"bytes,2,opt,name=err" json:"err,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RequestRunModelACK) Reset()         { *m = RequestRunModelACK{} }
func (m *RequestRunModelACK) String() string { return proto.CompactTextString(m) }
func (*RequestRunModelACK) ProtoMessage()    {}
func (*RequestRunModelACK) Descriptor() ([]byte, []int) {
	return fileDescriptor_8571034d60397816, []int{12}
}
func (m *RequestRunModelACK) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RequestRunModelACK) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RequestRunModelACK.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RequestRunModelACK) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RequestRunModelACK.Merge(m, src)
}
func (m *RequestRunModelACK) XXX_Size() int {
	return m.Size()
}
func (m *RequestRunModelACK) XXX_DiscardUnknown() {
	xxx_messageInfo_RequestRunModelACK.DiscardUnknown(m)
}

var xxx_messageInfo_RequestRunModelACK proto.InternalMessageInfo

func (m *RequestRunModelACK) GetCode() uint32 {
	if m != nil && m.Code != nil {
		return *m.Code
	}
	return 0
}

func (m *RequestRunModelACK) GetErr() string {
	if m != nil && m.Err != nil {
		return *m.Err
	}
	return ""
}

// ResponseRunModel is response of run data source model result
type ResponseRunModel struct {
	TaskHash             *string  `protobuf:"bytes,1,req,name=taskHash" json:"taskHash,omitempty"`
	ModelHash            *string  `protobuf:"bytes,2,req,name=modelHash" json:"modelHash,omitempty"`
	Code                 *uint32  `protobuf:"varint,3,req,name=code" json:"code,omitempty"`
	Res                  []byte   `protobuf:"bytes,4,opt,name=res" json:"res,omitempty"`
	Err                  *string  `protobuf:"bytes,5,opt,name=err" json:"err,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ResponseRunModel) Reset()         { *m = ResponseRunModel{} }
func (m *ResponseRunModel) String() string { return proto.CompactTextString(m) }
func (*ResponseRunModel) ProtoMessage()    {}
func (*ResponseRunModel) Descriptor() ([]byte, []int) {
	return fileDescriptor_8571034d60397816, []int{13}
}
func (m *ResponseRunModel) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResponseRunModel) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResponseRunModel.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResponseRunModel) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResponseRunModel.Merge(m, src)
}
func (m *ResponseRunModel) XXX_Size() int {
	return m.Size()
}
func (m *ResponseRunModel) XXX_DiscardUnknown() {
	xxx_messageInfo_ResponseRunModel.DiscardUnknown(m)
}

var xxx_messageInfo_ResponseRunModel proto.InternalMessageInfo

func (m *ResponseRunModel) GetTaskHash() string {
	if m != nil && m.TaskHash != nil {
		return *m.TaskHash
	}
	return ""
}

func (m *ResponseRunModel) GetModelHash() string {
	if m != nil && m.ModelHash != nil {
		return *m.ModelHash
	}
	return ""
}

func (m *ResponseRunModel) GetCode() uint32 {
	if m != nil && m.Code != nil {
		return *m.Code
	}
	return 0
}

func (m *ResponseRunModel) GetRes() []byte {
	if m != nil {
		return m.Res
	}
	return nil
}

func (m *ResponseRunModel) GetErr() string {
	if m != nil && m.Err != nil {
		return *m.Err
	}
	return ""
}

// ResponseRunModelACK is ACK of ResponseRunModel
type ResponseRunModelACK struct {
	Code                 *uint32  `protobuf:"varint,1,req,name=code" json:"code,omitempty"`
	Err                  *string  `protobuf:"bytes,2,opt,name=err" json:"err,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ResponseRunModelACK) Reset()         { *m = ResponseRunModelACK{} }
func (m *ResponseRunModelACK) String() string { return proto.CompactTextString(m) }
func (*ResponseRunModelACK) ProtoMessage()    {}
func (*ResponseRunModelACK) Descriptor() ([]byte, []int) {
	return fileDescriptor_8571034d60397816, []int{14}
}
func (m *ResponseRunModelACK) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResponseRunModelACK) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResponseRunModelACK.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResponseRunModelACK) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResponseRunModelACK.Merge(m, src)
}
func (m *ResponseRunModelACK) XXX_Size() int {
	return m.Size()
}
func (m *ResponseRunModelACK) XXX_DiscardUnknown() {
	xxx_messageInfo_ResponseRunModelACK.DiscardUnknown(m)
}

var xxx_messageInfo_ResponseRunModelACK proto.InternalMessageInfo

func (m *ResponseRunModelACK) GetCode() uint32 {
	if m != nil && m.Code != nil {
		return *m.Code
	}
	return 0
}

func (m *ResponseRunModelACK) GetErr() string {
	if m != nil && m.Err != nil {
		return *m.Err
	}
	return ""
}

// RequestCall request run model and restful
type RequestCall struct {
	TaskHash             *string  `protobuf:"bytes,1,req,name=taskHash" json:"taskHash,omitempty"`
	AppKey               *string  `protobuf:"bytes,2,req,name=appKey" json:"appKey,omitempty"`
	Method               *string  `protobuf:"bytes,3,req,name=method" json:"method,omitempty"`
	Args                 []byte   `protobuf:"bytes,4,req,name=args" json:"args,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RequestCall) Reset()         { *m = RequestCall{} }
func (m *RequestCall) String() string { return proto.CompactTextString(m) }
func (*RequestCall) ProtoMessage()    {}
func (*RequestCall) Descriptor() ([]byte, []int) {
	return fileDescriptor_8571034d60397816, []int{15}
}
func (m *RequestCall) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RequestCall) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RequestCall.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RequestCall) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RequestCall.Merge(m, src)
}
func (m *RequestCall) XXX_Size() int {
	return m.Size()
}
func (m *RequestCall) XXX_DiscardUnknown() {
	xxx_messageInfo_RequestCall.DiscardUnknown(m)
}

var xxx_messageInfo_RequestCall proto.InternalMessageInfo

func (m *RequestCall) GetTaskHash() string {
	if m != nil && m.TaskHash != nil {
		return *m.TaskHash
	}
	return ""
}

func (m *RequestCall) GetAppKey() string {
	if m != nil && m.AppKey != nil {
		return *m.AppKey
	}
	return ""
}

func (m *RequestCall) GetMethod() string {
	if m != nil && m.Method != nil {
		return *m.Method
	}
	return ""
}

func (m *RequestCall) GetArgs() []byte {
	if m != nil {
		return m.Args
	}
	return nil
}

// RequestCallACK is ACK of RequestCall
type RequestCallACK struct {
	Code                 *uint32  `protobuf:"varint,1,req,name=code" json:"code,omitempty"`
	Err                  *string  `protobuf:"bytes,2,opt,name=err" json:"err,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RequestCallACK) Reset()         { *m = RequestCallACK{} }
func (m *RequestCallACK) String() string { return proto.CompactTextString(m) }
func (*RequestCallACK) ProtoMessage()    {}
func (*RequestCallACK) Descriptor() ([]byte, []int) {
	return fileDescriptor_8571034d60397816, []int{16}
}
func (m *RequestCallACK) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RequestCallACK) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RequestCallACK.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RequestCallACK) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RequestCallACK.Merge(m, src)
}
func (m *RequestCallACK) XXX_Size() int {
	return m.Size()
}
func (m *RequestCallACK) XXX_DiscardUnknown() {
	xxx_messageInfo_RequestCallACK.DiscardUnknown(m)
}

var xxx_messageInfo_RequestCallACK proto.InternalMessageInfo

func (m *RequestCallACK) GetCode() uint32 {
	if m != nil && m.Code != nil {
		return *m.Code
	}
	return 0
}

func (m *RequestCallACK) GetErr() string {
	if m != nil && m.Err != nil {
		return *m.Err
	}
	return ""
}

// ResponseCall is response of run model and restful
type ResponseCall struct {
	TaskHash             *string  `protobuf:"bytes,1,req,name=taskHash" json:"taskHash,omitempty"`
	AppKey               *string  `protobuf:"bytes,2,req,name=appKey" json:"appKey,omitempty"`
	Code                 *uint32  `protobuf:"varint,3,req,name=code" json:"code,omitempty"`
	Res                  []byte   `protobuf:"bytes,4,opt,name=res" json:"res,omitempty"`
	Err                  *string  `protobuf:"bytes,5,opt,name=err" json:"err,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ResponseCall) Reset()         { *m = ResponseCall{} }
func (m *ResponseCall) String() string { return proto.CompactTextString(m) }
func (*ResponseCall) ProtoMessage()    {}
func (*ResponseCall) Descriptor() ([]byte, []int) {
	return fileDescriptor_8571034d60397816, []int{17}
}
func (m *ResponseCall) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResponseCall) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResponseCall.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResponseCall) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResponseCall.Merge(m, src)
}
func (m *ResponseCall) XXX_Size() int {
	return m.Size()
}
func (m *ResponseCall) XXX_DiscardUnknown() {
	xxx_messageInfo_ResponseCall.DiscardUnknown(m)
}

var xxx_messageInfo_ResponseCall proto.InternalMessageInfo

func (m *ResponseCall) GetTaskHash() string {
	if m != nil && m.TaskHash != nil {
		return *m.TaskHash
	}
	return ""
}

func (m *ResponseCall) GetAppKey() string {
	if m != nil && m.AppKey != nil {
		return *m.AppKey
	}
	return ""
}

func (m *ResponseCall) GetCode() uint32 {
	if m != nil && m.Code != nil {
		return *m.Code
	}
	return 0
}

func (m *ResponseCall) GetRes() []byte {
	if m != nil {
		return m.Res
	}
	return nil
}

func (m *ResponseCall) GetErr() string {
	if m != nil && m.Err != nil {
		return *m.Err
	}
	return ""
}

// ResponseCallACK is ACK of ResponseCall
type ResponseCallACK struct {
	Code                 *uint32  `protobuf:"varint,1,req,name=code" json:"code,omitempty"`
	Err                  *string  `protobuf:"bytes,2,opt,name=err" json:"err,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ResponseCallACK) Reset()         { *m = ResponseCallACK{} }
func (m *ResponseCallACK) String() string { return proto.CompactTextString(m) }
func (*ResponseCallACK) ProtoMessage()    {}
func (*ResponseCallACK) Descriptor() ([]byte, []int) {
	return fileDescriptor_8571034d60397816, []int{18}
}
func (m *ResponseCallACK) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResponseCallACK) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResponseCallACK.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResponseCallACK) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResponseCallACK.Merge(m, src)
}
func (m *ResponseCallACK) XXX_Size() int {
	return m.Size()
}
func (m *ResponseCallACK) XXX_DiscardUnknown() {
	xxx_messageInfo_ResponseCallACK.DiscardUnknown(m)
}

var xxx_messageInfo_ResponseCallACK proto.InternalMessageInfo

func (m *ResponseCallACK) GetCode() uint32 {
	if m != nil && m.Code != nil {
		return *m.Code
	}
	return 0
}

func (m *ResponseCallACK) GetErr() string {
	if m != nil && m.Err != nil {
		return *m.Err
	}
	return ""
}

// BXMNode is bitxmesh node info
type BXMNode struct {
	Id                   *string  `protobuf:"bytes,1,req,name=id" json:"id,omitempty"`
	Addrs                []string `protobuf:"bytes,2,rep,name=addrs" json:"addrs,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BXMNode) Reset()         { *m = BXMNode{} }
func (m *BXMNode) String() string { return proto.CompactTextString(m) }
func (*BXMNode) ProtoMessage()    {}
func (*BXMNode) Descriptor() ([]byte, []int) {
	return fileDescriptor_8571034d60397816, []int{19}
}
func (m *BXMNode) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BXMNode) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BXMNode.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BXMNode) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BXMNode.Merge(m, src)
}
func (m *BXMNode) XXX_Size() int {
	return m.Size()
}
func (m *BXMNode) XXX_DiscardUnknown() {
	xxx_messageInfo_BXMNode.DiscardUnknown(m)
}

var xxx_messageInfo_BXMNode proto.InternalMessageInfo

func (m *BXMNode) GetId() string {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return ""
}

func (m *BXMNode) GetAddrs() []string {
	if m != nil {
		return m.Addrs
	}
	return nil
}

// BXMNodes hold group id and BXMNode array
type BXMNodes struct {
	Gid                  *string    `protobuf:"bytes,1,req,name=gid" json:"gid,omitempty"`
	Nodes                []*BXMNode `protobuf:"bytes,2,rep,name=nodes" json:"nodes,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *BXMNodes) Reset()         { *m = BXMNodes{} }
func (m *BXMNodes) String() string { return proto.CompactTextString(m) }
func (*BXMNodes) ProtoMessage()    {}
func (*BXMNodes) Descriptor() ([]byte, []int) {
	return fileDescriptor_8571034d60397816, []int{20}
}
func (m *BXMNodes) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BXMNodes) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BXMNodes.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BXMNodes) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BXMNodes.Merge(m, src)
}
func (m *BXMNodes) XXX_Size() int {
	return m.Size()
}
func (m *BXMNodes) XXX_DiscardUnknown() {
	xxx_messageInfo_BXMNodes.DiscardUnknown(m)
}

var xxx_messageInfo_BXMNodes proto.InternalMessageInfo

func (m *BXMNodes) GetGid() string {
	if m != nil && m.Gid != nil {
		return *m.Gid
	}
	return ""
}

func (m *BXMNodes) GetNodes() []*BXMNode {
	if m != nil {
		return m.Nodes
	}
	return nil
}

// NodeGroupInfo is node group information
type NodeGroupInfo struct {
	Id                   *string  `protobuf:"bytes,1,req,name=id" json:"id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NodeGroupInfo) Reset()         { *m = NodeGroupInfo{} }
func (m *NodeGroupInfo) String() string { return proto.CompactTextString(m) }
func (*NodeGroupInfo) ProtoMessage()    {}
func (*NodeGroupInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_8571034d60397816, []int{21}
}
func (m *NodeGroupInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NodeGroupInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NodeGroupInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NodeGroupInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeGroupInfo.Merge(m, src)
}
func (m *NodeGroupInfo) XXX_Size() int {
	return m.Size()
}
func (m *NodeGroupInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeGroupInfo.DiscardUnknown(m)
}

var xxx_messageInfo_NodeGroupInfo proto.InternalMessageInfo

func (m *NodeGroupInfo) GetId() string {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return ""
}

// ResQuery is query of resource.
type ResQuery struct {
	Version              *string  `protobuf:"bytes,1,req,name=version" json:"version,omitempty"`
	BmID                 *string  `protobuf:"bytes,2,req,name=bmID" json:"bmID,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ResQuery) Reset()         { *m = ResQuery{} }
func (m *ResQuery) String() string { return proto.CompactTextString(m) }
func (*ResQuery) ProtoMessage()    {}
func (*ResQuery) Descriptor() ([]byte, []int) {
	return fileDescriptor_8571034d60397816, []int{22}
}
func (m *ResQuery) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResQuery) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResQuery.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResQuery) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResQuery.Merge(m, src)
}
func (m *ResQuery) XXX_Size() int {
	return m.Size()
}
func (m *ResQuery) XXX_DiscardUnknown() {
	xxx_messageInfo_ResQuery.DiscardUnknown(m)
}

var xxx_messageInfo_ResQuery proto.InternalMessageInfo

func (m *ResQuery) GetVersion() string {
	if m != nil && m.Version != nil {
		return *m.Version
	}
	return ""
}

func (m *ResQuery) GetBmID() string {
	if m != nil && m.BmID != nil {
		return *m.BmID
	}
	return ""
}

// ResQuery is ack of resource query.
type ResQueryACK struct {
	Version              *string  `protobuf:"bytes,1,req,name=version" json:"version,omitempty"`
	BmID                 *string  `protobuf:"bytes,2,req,name=bmID" json:"bmID,omitempty"`
	DiskTotalSize        *uint64  `protobuf:"varint,3,req,name=diskTotalSize" json:"diskTotalSize,omitempty"`
	DiskRestSize         *uint64  `protobuf:"varint,4,req,name=diskRestSize" json:"diskRestSize,omitempty"`
	CpuNum               *uint32  `protobuf:"varint,5,req,name=cpuNum" json:"cpuNum,omitempty"`
	Memory               *uint64  `protobuf:"varint,6,req,name=memory" json:"memory,omitempty"`
	Error                *string  `protobuf:"bytes,7,opt,name=error" json:"error,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ResQueryACK) Reset()         { *m = ResQueryACK{} }
func (m *ResQueryACK) String() string { return proto.CompactTextString(m) }
func (*ResQueryACK) ProtoMessage()    {}
func (*ResQueryACK) Descriptor() ([]byte, []int) {
	return fileDescriptor_8571034d60397816, []int{23}
}
func (m *ResQueryACK) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResQueryACK) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResQueryACK.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResQueryACK) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResQueryACK.Merge(m, src)
}
func (m *ResQueryACK) XXX_Size() int {
	return m.Size()
}
func (m *ResQueryACK) XXX_DiscardUnknown() {
	xxx_messageInfo_ResQueryACK.DiscardUnknown(m)
}

var xxx_messageInfo_ResQueryACK proto.InternalMessageInfo

func (m *ResQueryACK) GetVersion() string {
	if m != nil && m.Version != nil {
		return *m.Version
	}
	return ""
}

func (m *ResQueryACK) GetBmID() string {
	if m != nil && m.BmID != nil {
		return *m.BmID
	}
	return ""
}

func (m *ResQueryACK) GetDiskTotalSize() uint64 {
	if m != nil && m.DiskTotalSize != nil {
		return *m.DiskTotalSize
	}
	return 0
}

func (m *ResQueryACK) GetDiskRestSize() uint64 {
	if m != nil && m.DiskRestSize != nil {
		return *m.DiskRestSize
	}
	return 0
}

func (m *ResQueryACK) GetCpuNum() uint32 {
	if m != nil && m.CpuNum != nil {
		return *m.CpuNum
	}
	return 0
}

func (m *ResQueryACK) GetMemory() uint64 {
	if m != nil && m.Memory != nil {
		return *m.Memory
	}
	return 0
}

func (m *ResQueryACK) GetError() string {
	if m != nil && m.Error != nil {
		return *m.Error
	}
	return ""
}

// ClusterFilesAdd is adding file to cluster.
type ClusterFilesAdd struct {
	Version              *string  `protobuf:"bytes,1,req,name=version" json:"version,omitempty"`
	Did                  *string  `protobuf:"bytes,2,req,name=did" json:"did,omitempty"`
	Data                 []byte   `protobuf:"bytes,3,req,name=data" json:"data,omitempty"`
	Error                *string  `protobuf:"bytes,4,opt,name=error" json:"error,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ClusterFilesAdd) Reset()         { *m = ClusterFilesAdd{} }
func (m *ClusterFilesAdd) String() string { return proto.CompactTextString(m) }
func (*ClusterFilesAdd) ProtoMessage()    {}
func (*ClusterFilesAdd) Descriptor() ([]byte, []int) {
	return fileDescriptor_8571034d60397816, []int{24}
}
func (m *ClusterFilesAdd) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClusterFilesAdd) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClusterFilesAdd.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClusterFilesAdd) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClusterFilesAdd.Merge(m, src)
}
func (m *ClusterFilesAdd) XXX_Size() int {
	return m.Size()
}
func (m *ClusterFilesAdd) XXX_DiscardUnknown() {
	xxx_messageInfo_ClusterFilesAdd.DiscardUnknown(m)
}

var xxx_messageInfo_ClusterFilesAdd proto.InternalMessageInfo

func (m *ClusterFilesAdd) GetVersion() string {
	if m != nil && m.Version != nil {
		return *m.Version
	}
	return ""
}

func (m *ClusterFilesAdd) GetDid() string {
	if m != nil && m.Did != nil {
		return *m.Did
	}
	return ""
}

func (m *ClusterFilesAdd) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *ClusterFilesAdd) GetError() string {
	if m != nil && m.Error != nil {
		return *m.Error
	}
	return ""
}

// ClusterFilesAddACK is ack of adding file to cluster.
type ClusterFilesAddACK struct {
	Version              *string  `protobuf:"bytes,1,req,name=version" json:"version,omitempty"`
	Error                *string  `protobuf:"bytes,2,opt,name=error" json:"error,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ClusterFilesAddACK) Reset()         { *m = ClusterFilesAddACK{} }
func (m *ClusterFilesAddACK) String() string { return proto.CompactTextString(m) }
func (*ClusterFilesAddACK) ProtoMessage()    {}
func (*ClusterFilesAddACK) Descriptor() ([]byte, []int) {
	return fileDescriptor_8571034d60397816, []int{25}
}
func (m *ClusterFilesAddACK) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClusterFilesAddACK) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClusterFilesAddACK.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClusterFilesAddACK) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClusterFilesAddACK.Merge(m, src)
}
func (m *ClusterFilesAddACK) XXX_Size() int {
	return m.Size()
}
func (m *ClusterFilesAddACK) XXX_DiscardUnknown() {
	xxx_messageInfo_ClusterFilesAddACK.DiscardUnknown(m)
}

var xxx_messageInfo_ClusterFilesAddACK proto.InternalMessageInfo

func (m *ClusterFilesAddACK) GetVersion() string {
	if m != nil && m.Version != nil {
		return *m.Version
	}
	return ""
}

func (m *ClusterFilesAddACK) GetError() string {
	if m != nil && m.Error != nil {
		return *m.Error
	}
	return ""
}

// ClusterFilesTake takes file
type ClusterFilesTake struct {
	Version              *string  `protobuf:"bytes,1,req,name=version" json:"version,omitempty"`
	Did                  *string  `protobuf:"bytes,2,req,name=did" json:"did,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ClusterFilesTake) Reset()         { *m = ClusterFilesTake{} }
func (m *ClusterFilesTake) String() string { return proto.CompactTextString(m) }
func (*ClusterFilesTake) ProtoMessage()    {}
func (*ClusterFilesTake) Descriptor() ([]byte, []int) {
	return fileDescriptor_8571034d60397816, []int{26}
}
func (m *ClusterFilesTake) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClusterFilesTake) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClusterFilesTake.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClusterFilesTake) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClusterFilesTake.Merge(m, src)
}
func (m *ClusterFilesTake) XXX_Size() int {
	return m.Size()
}
func (m *ClusterFilesTake) XXX_DiscardUnknown() {
	xxx_messageInfo_ClusterFilesTake.DiscardUnknown(m)
}

var xxx_messageInfo_ClusterFilesTake proto.InternalMessageInfo

func (m *ClusterFilesTake) GetVersion() string {
	if m != nil && m.Version != nil {
		return *m.Version
	}
	return ""
}

func (m *ClusterFilesTake) GetDid() string {
	if m != nil && m.Did != nil {
		return *m.Did
	}
	return ""
}

// ClusterFilesTakeACK is ClusterFilesTake ACK
type ClusterFilesTakeACK struct {
	Version              *string  `protobuf:"bytes,1,req,name=version" json:"version,omitempty"`
	Did                  *string  `protobuf:"bytes,2,req,name=did" json:"did,omitempty"`
	Data                 []byte   `protobuf:"bytes,3,req,name=data" json:"data,omitempty"`
	Error                *string  `protobuf:"bytes,4,opt,name=error" json:"error,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ClusterFilesTakeACK) Reset()         { *m = ClusterFilesTakeACK{} }
func (m *ClusterFilesTakeACK) String() string { return proto.CompactTextString(m) }
func (*ClusterFilesTakeACK) ProtoMessage()    {}
func (*ClusterFilesTakeACK) Descriptor() ([]byte, []int) {
	return fileDescriptor_8571034d60397816, []int{27}
}
func (m *ClusterFilesTakeACK) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClusterFilesTakeACK) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClusterFilesTakeACK.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClusterFilesTakeACK) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClusterFilesTakeACK.Merge(m, src)
}
func (m *ClusterFilesTakeACK) XXX_Size() int {
	return m.Size()
}
func (m *ClusterFilesTakeACK) XXX_DiscardUnknown() {
	xxx_messageInfo_ClusterFilesTakeACK.DiscardUnknown(m)
}

var xxx_messageInfo_ClusterFilesTakeACK proto.InternalMessageInfo

func (m *ClusterFilesTakeACK) GetVersion() string {
	if m != nil && m.Version != nil {
		return *m.Version
	}
	return ""
}

func (m *ClusterFilesTakeACK) GetDid() string {
	if m != nil && m.Did != nil {
		return *m.Did
	}
	return ""
}

func (m *ClusterFilesTakeACK) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *ClusterFilesTakeACK) GetError() string {
	if m != nil && m.Error != nil {
		return *m.Error
	}
	return ""
}

// ClusterFilesDelete deletes file
type ClusterFilesDelete struct {
	Version              *string  `protobuf:"bytes,1,req,name=version" json:"version,omitempty"`
	Did                  *string  `protobuf:"bytes,2,req,name=did" json:"did,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ClusterFilesDelete) Reset()         { *m = ClusterFilesDelete{} }
func (m *ClusterFilesDelete) String() string { return proto.CompactTextString(m) }
func (*ClusterFilesDelete) ProtoMessage()    {}
func (*ClusterFilesDelete) Descriptor() ([]byte, []int) {
	return fileDescriptor_8571034d60397816, []int{28}
}
func (m *ClusterFilesDelete) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClusterFilesDelete) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClusterFilesDelete.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClusterFilesDelete) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClusterFilesDelete.Merge(m, src)
}
func (m *ClusterFilesDelete) XXX_Size() int {
	return m.Size()
}
func (m *ClusterFilesDelete) XXX_DiscardUnknown() {
	xxx_messageInfo_ClusterFilesDelete.DiscardUnknown(m)
}

var xxx_messageInfo_ClusterFilesDelete proto.InternalMessageInfo

func (m *ClusterFilesDelete) GetVersion() string {
	if m != nil && m.Version != nil {
		return *m.Version
	}
	return ""
}

func (m *ClusterFilesDelete) GetDid() string {
	if m != nil && m.Did != nil {
		return *m.Did
	}
	return ""
}

// ClusterFilesDeleteACK is ClusterFilesDelete ACK
type ClusterFilesDeleteACK struct {
	Version              *string  `protobuf:"bytes,1,req,name=version" json:"version,omitempty"`
	Did                  *string  `protobuf:"bytes,2,req,name=did" json:"did,omitempty"`
	Error                *string  `protobuf:"bytes,3,opt,name=error" json:"error,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ClusterFilesDeleteACK) Reset()         { *m = ClusterFilesDeleteACK{} }
func (m *ClusterFilesDeleteACK) String() string { return proto.CompactTextString(m) }
func (*ClusterFilesDeleteACK) ProtoMessage()    {}
func (*ClusterFilesDeleteACK) Descriptor() ([]byte, []int) {
	return fileDescriptor_8571034d60397816, []int{29}
}
func (m *ClusterFilesDeleteACK) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClusterFilesDeleteACK) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClusterFilesDeleteACK.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClusterFilesDeleteACK) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClusterFilesDeleteACK.Merge(m, src)
}
func (m *ClusterFilesDeleteACK) XXX_Size() int {
	return m.Size()
}
func (m *ClusterFilesDeleteACK) XXX_DiscardUnknown() {
	xxx_messageInfo_ClusterFilesDeleteACK.DiscardUnknown(m)
}

var xxx_messageInfo_ClusterFilesDeleteACK proto.InternalMessageInfo

func (m *ClusterFilesDeleteACK) GetVersion() string {
	if m != nil && m.Version != nil {
		return *m.Version
	}
	return ""
}

func (m *ClusterFilesDeleteACK) GetDid() string {
	if m != nil && m.Did != nil {
		return *m.Did
	}
	return ""
}

func (m *ClusterFilesDeleteACK) GetError() string {
	if m != nil && m.Error != nil {
		return *m.Error
	}
	return ""
}

// FCRequest is request of federated computation
type FCRequest struct {
	FCID                 *string           `protobuf:"bytes,1,req,name=FCID" json:"FCID,omitempty"`
	TaskID               *string           `protobuf:"bytes,2,req,name=taskID" json:"taskID,omitempty"`
	Caller               *string           `protobuf:"bytes,3,req,name=caller" json:"caller,omitempty"`
	VmType               *uint32           `protobuf:"varint,4,req,name=vmType" json:"vmType,omitempty"`
	ExecuteContent       *FCExecuteContent `protobuf:"bytes,5,req,name=executeContent" json:"executeContent,omitempty"`
	Type                 *FCRequest_FCType `protobuf:"varint,6,req,name=type,enum=pb.FCRequest_FCType" json:"type,omitempty"`
	External             []byte            `protobuf:"bytes,7,opt,name=external" json:"external,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *FCRequest) Reset()         { *m = FCRequest{} }
func (m *FCRequest) String() string { return proto.CompactTextString(m) }
func (*FCRequest) ProtoMessage()    {}
func (*FCRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_8571034d60397816, []int{30}
}
func (m *FCRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FCRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FCRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FCRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FCRequest.Merge(m, src)
}
func (m *FCRequest) XXX_Size() int {
	return m.Size()
}
func (m *FCRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_FCRequest.DiscardUnknown(m)
}

var xxx_messageInfo_FCRequest proto.InternalMessageInfo

func (m *FCRequest) GetFCID() string {
	if m != nil && m.FCID != nil {
		return *m.FCID
	}
	return ""
}

func (m *FCRequest) GetTaskID() string {
	if m != nil && m.TaskID != nil {
		return *m.TaskID
	}
	return ""
}

func (m *FCRequest) GetCaller() string {
	if m != nil && m.Caller != nil {
		return *m.Caller
	}
	return ""
}

func (m *FCRequest) GetVmType() uint32 {
	if m != nil && m.VmType != nil {
		return *m.VmType
	}
	return 0
}

func (m *FCRequest) GetExecuteContent() *FCExecuteContent {
	if m != nil {
		return m.ExecuteContent
	}
	return nil
}

func (m *FCRequest) GetType() FCRequest_FCType {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return FCRequest_NORMAL_INVOKE
}

func (m *FCRequest) GetExternal() []byte {
	if m != nil {
		return m.External
	}
	return nil
}

type PSAInvokeExternal struct {
	ParticipantList      map[uint32]string          `protobuf:"bytes,1,rep,name=ParticipantList" json:"ParticipantList,omitempty" protobuf_key:"varint,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	Type                 *PSAInvokeExternal_PSAType `protobuf:"varint,2,req,name=type,enum=pb.PSAInvokeExternal_PSAType" json:"type,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                   `json:"-"`
	XXX_unrecognized     []byte                     `json:"-"`
	XXX_sizecache        int32                      `json:"-"`
}

func (m *PSAInvokeExternal) Reset()         { *m = PSAInvokeExternal{} }
func (m *PSAInvokeExternal) String() string { return proto.CompactTextString(m) }
func (*PSAInvokeExternal) ProtoMessage()    {}
func (*PSAInvokeExternal) Descriptor() ([]byte, []int) {
	return fileDescriptor_8571034d60397816, []int{31}
}
func (m *PSAInvokeExternal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PSAInvokeExternal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PSAInvokeExternal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PSAInvokeExternal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PSAInvokeExternal.Merge(m, src)
}
func (m *PSAInvokeExternal) XXX_Size() int {
	return m.Size()
}
func (m *PSAInvokeExternal) XXX_DiscardUnknown() {
	xxx_messageInfo_PSAInvokeExternal.DiscardUnknown(m)
}

var xxx_messageInfo_PSAInvokeExternal proto.InternalMessageInfo

func (m *PSAInvokeExternal) GetParticipantList() map[uint32]string {
	if m != nil {
		return m.ParticipantList
	}
	return nil
}

func (m *PSAInvokeExternal) GetType() PSAInvokeExternal_PSAType {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return PSAInvokeExternal_ADD
}

type PSIInvokeExternal struct {
	SetSize              *uint32  `protobuf:"varint,1,req,name=SetSize" json:"SetSize,omitempty"`
	N                    []byte   `protobuf:"bytes,2,req,name=N" json:"N,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PSIInvokeExternal) Reset()         { *m = PSIInvokeExternal{} }
func (m *PSIInvokeExternal) String() string { return proto.CompactTextString(m) }
func (*PSIInvokeExternal) ProtoMessage()    {}
func (*PSIInvokeExternal) Descriptor() ([]byte, []int) {
	return fileDescriptor_8571034d60397816, []int{32}
}
func (m *PSIInvokeExternal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PSIInvokeExternal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PSIInvokeExternal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PSIInvokeExternal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PSIInvokeExternal.Merge(m, src)
}
func (m *PSIInvokeExternal) XXX_Size() int {
	return m.Size()
}
func (m *PSIInvokeExternal) XXX_DiscardUnknown() {
	xxx_messageInfo_PSIInvokeExternal.DiscardUnknown(m)
}

var xxx_messageInfo_PSIInvokeExternal proto.InternalMessageInfo

func (m *PSIInvokeExternal) GetSetSize() uint32 {
	if m != nil && m.SetSize != nil {
		return *m.SetSize
	}
	return 0
}

func (m *PSIInvokeExternal) GetN() []byte {
	if m != nil {
		return m.N
	}
	return nil
}

// FCExecuteContent is federated computation execute content
type FCExecuteContent struct {
	ModelID              *string  `protobuf:"bytes,1,req,name=modelID" json:"modelID,omitempty"`
	AppKey               *string  `protobuf:"bytes,2,req,name=appKey" json:"appKey,omitempty"`
	Method               *string  `protobuf:"bytes,3,req,name=method" json:"method,omitempty"`
	Args                 []byte   `protobuf:"bytes,4,req,name=args" json:"args,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FCExecuteContent) Reset()         { *m = FCExecuteContent{} }
func (m *FCExecuteContent) String() string { return proto.CompactTextString(m) }
func (*FCExecuteContent) ProtoMessage()    {}
func (*FCExecuteContent) Descriptor() ([]byte, []int) {
	return fileDescriptor_8571034d60397816, []int{33}
}
func (m *FCExecuteContent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FCExecuteContent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FCExecuteContent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FCExecuteContent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FCExecuteContent.Merge(m, src)
}
func (m *FCExecuteContent) XXX_Size() int {
	return m.Size()
}
func (m *FCExecuteContent) XXX_DiscardUnknown() {
	xxx_messageInfo_FCExecuteContent.DiscardUnknown(m)
}

var xxx_messageInfo_FCExecuteContent proto.InternalMessageInfo

func (m *FCExecuteContent) GetModelID() string {
	if m != nil && m.ModelID != nil {
		return *m.ModelID
	}
	return ""
}

func (m *FCExecuteContent) GetAppKey() string {
	if m != nil && m.AppKey != nil {
		return *m.AppKey
	}
	return ""
}

func (m *FCExecuteContent) GetMethod() string {
	if m != nil && m.Method != nil {
		return *m.Method
	}
	return ""
}

func (m *FCExecuteContent) GetArgs() []byte {
	if m != nil {
		return m.Args
	}
	return nil
}

// FCResponse is response of federated computation
type FCResponse struct {
	FCID                 *string  `protobuf:"bytes,1,req,name=FCID" json:"FCID,omitempty"`
	Code                 *uint32  `protobuf:"varint,2,req,name=code" json:"code,omitempty"`
	Res                  []byte   `protobuf:"bytes,3,opt,name=res" json:"res,omitempty"`
	Err                  *string  `protobuf:"bytes,4,opt,name=err" json:"err,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FCResponse) Reset()         { *m = FCResponse{} }
func (m *FCResponse) String() string { return proto.CompactTextString(m) }
func (*FCResponse) ProtoMessage()    {}
func (*FCResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_8571034d60397816, []int{34}
}
func (m *FCResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FCResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FCResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FCResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FCResponse.Merge(m, src)
}
func (m *FCResponse) XXX_Size() int {
	return m.Size()
}
func (m *FCResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_FCResponse.DiscardUnknown(m)
}

var xxx_messageInfo_FCResponse proto.InternalMessageInfo

func (m *FCResponse) GetFCID() string {
	if m != nil && m.FCID != nil {
		return *m.FCID
	}
	return ""
}

func (m *FCResponse) GetCode() uint32 {
	if m != nil && m.Code != nil {
		return *m.Code
	}
	return 0
}

func (m *FCResponse) GetRes() []byte {
	if m != nil {
		return m.Res
	}
	return nil
}

func (m *FCResponse) GetErr() string {
	if m != nil && m.Err != nil {
		return *m.Err
	}
	return ""
}

// FCIntermediateMessage is federated computation intermediate message
type FCIntermediateMessage struct {
	FCID                 *string                     `protobuf:"bytes,1,req,name=FCID" json:"FCID,omitempty"`
	Type                 *FCIntermediateMessage_Type `protobuf:"varint,2,req,name=type,enum=pb.FCIntermediateMessage_Type" json:"type,omitempty"`
	Body                 []byte                      `protobuf:"bytes,3,req,name=body" json:"body,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                    `json:"-"`
	XXX_unrecognized     []byte                      `json:"-"`
	XXX_sizecache        int32                       `json:"-"`
}

func (m *FCIntermediateMessage) Reset()         { *m = FCIntermediateMessage{} }
func (m *FCIntermediateMessage) String() string { return proto.CompactTextString(m) }
func (*FCIntermediateMessage) ProtoMessage()    {}
func (*FCIntermediateMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_8571034d60397816, []int{35}
}
func (m *FCIntermediateMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FCIntermediateMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FCIntermediateMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FCIntermediateMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FCIntermediateMessage.Merge(m, src)
}
func (m *FCIntermediateMessage) XXX_Size() int {
	return m.Size()
}
func (m *FCIntermediateMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_FCIntermediateMessage.DiscardUnknown(m)
}

var xxx_messageInfo_FCIntermediateMessage proto.InternalMessageInfo

func (m *FCIntermediateMessage) GetFCID() string {
	if m != nil && m.FCID != nil {
		return *m.FCID
	}
	return ""
}

func (m *FCIntermediateMessage) GetType() FCIntermediateMessage_Type {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return FCIntermediateMessage_KEY_REQUEST
}

func (m *FCIntermediateMessage) GetBody() []byte {
	if m != nil {
		return m.Body
	}
	return nil
}

type PSIMaskRequestBody struct {
	StartNumber          *uint32  `protobuf:"varint,1,req,name=StartNumber" json:"StartNumber,omitempty"`
	SubSet               [][]byte `protobuf:"bytes,2,rep,name=SubSet" json:"SubSet,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PSIMaskRequestBody) Reset()         { *m = PSIMaskRequestBody{} }
func (m *PSIMaskRequestBody) String() string { return proto.CompactTextString(m) }
func (*PSIMaskRequestBody) ProtoMessage()    {}
func (*PSIMaskRequestBody) Descriptor() ([]byte, []int) {
	return fileDescriptor_8571034d60397816, []int{36}
}
func (m *PSIMaskRequestBody) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PSIMaskRequestBody) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PSIMaskRequestBody.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PSIMaskRequestBody) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PSIMaskRequestBody.Merge(m, src)
}
func (m *PSIMaskRequestBody) XXX_Size() int {
	return m.Size()
}
func (m *PSIMaskRequestBody) XXX_DiscardUnknown() {
	xxx_messageInfo_PSIMaskRequestBody.DiscardUnknown(m)
}

var xxx_messageInfo_PSIMaskRequestBody proto.InternalMessageInfo

func (m *PSIMaskRequestBody) GetStartNumber() uint32 {
	if m != nil && m.StartNumber != nil {
		return *m.StartNumber
	}
	return 0
}

func (m *PSIMaskRequestBody) GetSubSet() [][]byte {
	if m != nil {
		return m.SubSet
	}
	return nil
}

type PSIMaskResponseInitBody struct {
	RoundNumber          *uint32  `protobuf:"varint,1,req,name=RoundNumber" json:"RoundNumber,omitempty"`
	TableSize            *uint32  `protobuf:"varint,2,req,name=TableSize" json:"TableSize,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PSIMaskResponseInitBody) Reset()         { *m = PSIMaskResponseInitBody{} }
func (m *PSIMaskResponseInitBody) String() string { return proto.CompactTextString(m) }
func (*PSIMaskResponseInitBody) ProtoMessage()    {}
func (*PSIMaskResponseInitBody) Descriptor() ([]byte, []int) {
	return fileDescriptor_8571034d60397816, []int{37}
}
func (m *PSIMaskResponseInitBody) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PSIMaskResponseInitBody) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PSIMaskResponseInitBody.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PSIMaskResponseInitBody) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PSIMaskResponseInitBody.Merge(m, src)
}
func (m *PSIMaskResponseInitBody) XXX_Size() int {
	return m.Size()
}
func (m *PSIMaskResponseInitBody) XXX_DiscardUnknown() {
	xxx_messageInfo_PSIMaskResponseInitBody.DiscardUnknown(m)
}

var xxx_messageInfo_PSIMaskResponseInitBody proto.InternalMessageInfo

func (m *PSIMaskResponseInitBody) GetRoundNumber() uint32 {
	if m != nil && m.RoundNumber != nil {
		return *m.RoundNumber
	}
	return 0
}

func (m *PSIMaskResponseInitBody) GetTableSize() uint32 {
	if m != nil && m.TableSize != nil {
		return *m.TableSize
	}
	return 0
}

type PSIMaskResponseBody struct {
	Buckets              []*PSIBucket `protobuf:"bytes,1,rep,name=Buckets" json:"Buckets,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *PSIMaskResponseBody) Reset()         { *m = PSIMaskResponseBody{} }
func (m *PSIMaskResponseBody) String() string { return proto.CompactTextString(m) }
func (*PSIMaskResponseBody) ProtoMessage()    {}
func (*PSIMaskResponseBody) Descriptor() ([]byte, []int) {
	return fileDescriptor_8571034d60397816, []int{38}
}
func (m *PSIMaskResponseBody) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PSIMaskResponseBody) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PSIMaskResponseBody.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PSIMaskResponseBody) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PSIMaskResponseBody.Merge(m, src)
}
func (m *PSIMaskResponseBody) XXX_Size() int {
	return m.Size()
}
func (m *PSIMaskResponseBody) XXX_DiscardUnknown() {
	xxx_messageInfo_PSIMaskResponseBody.DiscardUnknown(m)
}

var xxx_messageInfo_PSIMaskResponseBody proto.InternalMessageInfo

func (m *PSIMaskResponseBody) GetBuckets() []*PSIBucket {
	if m != nil {
		return m.Buckets
	}
	return nil
}

type PSIBucket struct {
	Number               *uint32       `protobuf:"varint,1,req,name=Number" json:"Number,omitempty"`
	Set                  []*PSISetData `protobuf:"bytes,2,rep,name=Set" json:"Set,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *PSIBucket) Reset()         { *m = PSIBucket{} }
func (m *PSIBucket) String() string { return proto.CompactTextString(m) }
func (*PSIBucket) ProtoMessage()    {}
func (*PSIBucket) Descriptor() ([]byte, []int) {
	return fileDescriptor_8571034d60397816, []int{39}
}
func (m *PSIBucket) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PSIBucket) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PSIBucket.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PSIBucket) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PSIBucket.Merge(m, src)
}
func (m *PSIBucket) XXX_Size() int {
	return m.Size()
}
func (m *PSIBucket) XXX_DiscardUnknown() {
	xxx_messageInfo_PSIBucket.DiscardUnknown(m)
}

var xxx_messageInfo_PSIBucket proto.InternalMessageInfo

func (m *PSIBucket) GetNumber() uint32 {
	if m != nil && m.Number != nil {
		return *m.Number
	}
	return 0
}

func (m *PSIBucket) GetSet() []*PSISetData {
	if m != nil {
		return m.Set
	}
	return nil
}

type PSISetData struct {
	Index                *uint32  `protobuf:"varint,1,req,name=Index" json:"Index,omitempty"`
	Data                 []byte   `protobuf:"bytes,2,req,name=Data" json:"Data,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PSISetData) Reset()         { *m = PSISetData{} }
func (m *PSISetData) String() string { return proto.CompactTextString(m) }
func (*PSISetData) ProtoMessage()    {}
func (*PSISetData) Descriptor() ([]byte, []int) {
	return fileDescriptor_8571034d60397816, []int{40}
}
func (m *PSISetData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PSISetData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PSISetData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PSISetData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PSISetData.Merge(m, src)
}
func (m *PSISetData) XXX_Size() int {
	return m.Size()
}
func (m *PSISetData) XXX_DiscardUnknown() {
	xxx_messageInfo_PSISetData.DiscardUnknown(m)
}

var xxx_messageInfo_PSISetData proto.InternalMessageInfo

func (m *PSISetData) GetIndex() uint32 {
	if m != nil && m.Index != nil {
		return *m.Index
	}
	return 0
}

func (m *PSISetData) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func init() {
	proto.RegisterEnum("pb.Message_Type", Message_Type_name, Message_Type_value)
	proto.RegisterEnum("pb.FCRequest_FCType", FCRequest_FCType_name, FCRequest_FCType_value)
	proto.RegisterEnum("pb.PSAInvokeExternal_PSAType", PSAInvokeExternal_PSAType_name, PSAInvokeExternal_PSAType_value)
	proto.RegisterEnum("pb.FCIntermediateMessage_Type", FCIntermediateMessage_Type_name, FCIntermediateMessage_Type_value)
	proto.RegisterType((*FetchData)(nil), "pb.FetchData")
	proto.RegisterType((*FetchDataACK)(nil), "pb.FetchDataACK")
	proto.RegisterType((*Message)(nil), "pb.Message")
	proto.RegisterType((*RemoteRequest)(nil), "pb.RemoteRequest")
	proto.RegisterType((*RemoteResponse)(nil), "pb.RemoteResponse")
	proto.RegisterType((*RequestCheckModel)(nil), "pb.RequestCheckModel")
	proto.RegisterType((*RequestCheckModelACK)(nil), "pb.RequestCheckModelACK")
	proto.RegisterType((*CheckModel)(nil), "pb.CheckModel")
	proto.RegisterType((*CheckModelACK)(nil), "pb.CheckModelACK")
	proto.RegisterType((*CancelTask)(nil), "pb.CancelTask")
	proto.RegisterType((*CancelTaskACK)(nil), "pb.CancelTaskACK")
	proto.RegisterType((*RequestRunModel)(nil), "pb.RequestRunModel")
	proto.RegisterType((*RequestRunModelACK)(nil), "pb.RequestRunModelACK")
	proto.RegisterType((*ResponseRunModel)(nil), "pb.ResponseRunModel")
	proto.RegisterType((*ResponseRunModelACK)(nil), "pb.ResponseRunModelACK")
	proto.RegisterType((*RequestCall)(nil), "pb.RequestCall")
	proto.RegisterType((*RequestCallACK)(nil), "pb.RequestCallACK")
	proto.RegisterType((*ResponseCall)(nil), "pb.ResponseCall")
	proto.RegisterType((*ResponseCallACK)(nil), "pb.ResponseCallACK")
	proto.RegisterType((*BXMNode)(nil), "pb.BXMNode")
	proto.RegisterType((*BXMNodes)(nil), "pb.BXMNodes")
	proto.RegisterType((*NodeGroupInfo)(nil), "pb.NodeGroupInfo")
	proto.RegisterType((*ResQuery)(nil), "pb.ResQuery")
	proto.RegisterType((*ResQueryACK)(nil), "pb.ResQueryACK")
	proto.RegisterType((*ClusterFilesAdd)(nil), "pb.ClusterFilesAdd")
	proto.RegisterType((*ClusterFilesAddACK)(nil), "pb.ClusterFilesAddACK")
	proto.RegisterType((*ClusterFilesTake)(nil), "pb.ClusterFilesTake")
	proto.RegisterType((*ClusterFilesTakeACK)(nil), "pb.ClusterFilesTakeACK")
	proto.RegisterType((*ClusterFilesDelete)(nil), "pb.ClusterFilesDelete")
	proto.RegisterType((*ClusterFilesDeleteACK)(nil), "pb.ClusterFilesDeleteACK")
	proto.RegisterType((*FCRequest)(nil), "pb.FCRequest")
	proto.RegisterType((*PSAInvokeExternal)(nil), "pb.PSAInvokeExternal")
	proto.RegisterMapType((map[uint32]string)(nil), "pb.PSAInvokeExternal.ParticipantListEntry")
	proto.RegisterType((*PSIInvokeExternal)(nil), "pb.PSIInvokeExternal")
	proto.RegisterType((*FCExecuteContent)(nil), "pb.FCExecuteContent")
	proto.RegisterType((*FCResponse)(nil), "pb.FCResponse")
	proto.RegisterType((*FCIntermediateMessage)(nil), "pb.FCIntermediateMessage")
	proto.RegisterType((*PSIMaskRequestBody)(nil), "pb.PSIMaskRequestBody")
	proto.RegisterType((*PSIMaskResponseInitBody)(nil), "pb.PSIMaskResponseInitBody")
	proto.RegisterType((*PSIMaskResponseBody)(nil), "pb.PSIMaskResponseBody")
	proto.RegisterType((*PSIBucket)(nil), "pb.PSIBucket")
	proto.RegisterType((*PSISetData)(nil), "pb.PSISetData")
}

func init() { proto.RegisterFile("network.proto", fileDescriptor_8571034d60397816) }

var fileDescriptor_8571034d60397816 = []byte{
	// 1841 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x58, 0xdd, 0x6e, 0xdb, 0xc8,
	0x15, 0x2e, 0x29, 0xd9, 0xb2, 0x8e, 0x7e, 0x4c, 0x8f, 0x7f, 0xa2, 0x75, 0x12, 0xaf, 0x42, 0x2c,
	0xb0, 0x6e, 0x81, 0xba, 0xa8, 0x81, 0x6e, 0x83, 0xcd, 0x62, 0x5b, 0x59, 0xa2, 0x62, 0x42, 0x32,
	0xed, 0x0c, 0xe5, 0xed, 0xe6, 0xa6, 0x02, 0x2d, 0xce, 0xca, 0x82, 0x24, 0x52, 0x25, 0x47, 0x69,
	0xbc, 0x17, 0xbd, 0xea, 0x1b, 0xf4, 0xa6, 0x8f, 0xd0, 0xbb, 0xbe, 0x46, 0x81, 0xde, 0xf4, 0x0d,
	0x5a, 0xa4, 0x4f, 0xd0, 0xeb, 0xa2, 0x40, 0x71, 0x86, 0xc3, 0x1f, 0xfd, 0x24, 0x70, 0xb2, 0xb9,
	0x9b, 0xf3, 0x33, 0xe7, 0x7c, 0x67, 0x78, 0xe6, 0xcc, 0x39, 0x84, 0x8a, 0xc7, 0xf8, 0xef, 0xfd,
	0x60, 0x7c, 0x32, 0x0b, 0x7c, 0xee, 0x13, 0x75, 0x76, 0xa3, 0x0f, 0xa1, 0xd8, 0x66, 0x7c, 0x70,
	0xdb, 0x72, 0xb8, 0x43, 0x0e, 0x60, 0xd3, 0x99, 0xcd, 0x3a, 0xec, 0xae, 0xa6, 0xd4, 0xd5, 0xe3,
	0x22, 0x95, 0x14, 0x21, 0x90, 0x77, 0x82, 0x61, 0x58, 0x53, 0xeb, 0xea, 0x71, 0x99, 0x8a, 0x35,
	0x39, 0x84, 0xad, 0xef, 0xe6, 0xde, 0x80, 0x8f, 0x7c, 0xaf, 0x96, 0x13, 0xda, 0x09, 0x8d, 0xfa,
	0x1e, 0x65, 0xbc, 0x96, 0xaf, 0xab, 0xc7, 0x15, 0x2a, 0xd6, 0xfa, 0x0d, 0x94, 0x13, 0x47, 0x8d,
	0x66, 0x87, 0x68, 0x90, 0x73, 0x47, 0xae, 0x74, 0x84, 0x4b, 0xdc, 0xe5, 0x3a, 0xdc, 0xa9, 0xa9,
	0x75, 0x05, 0xbd, 0xb8, 0x12, 0xd1, 0x84, 0x79, 0x43, 0x7e, 0x5b, 0xcb, 0xd5, 0x95, 0xe3, 0x3c,
	0x95, 0x14, 0xd9, 0x83, 0x0d, 0x16, 0x04, 0x7e, 0x50, 0xcb, 0xd7, 0x95, 0xe3, 0x22, 0x8d, 0x08,
	0xfd, 0x4f, 0x05, 0x28, 0x5c, 0xb0, 0x30, 0x74, 0x86, 0x8c, 0x7c, 0x06, 0x79, 0x7e, 0x37, 0x63,
	0xc2, 0x41, 0xf5, 0x54, 0x3b, 0x99, 0xdd, 0x9c, 0x48, 0xd1, 0x49, 0xef, 0x6e, 0xc6, 0xa8, 0x90,
	0xa2, 0xcf, 0x1b, 0xdf, 0xbd, 0x8b, 0x23, 0xc3, 0x35, 0x79, 0x04, 0xc5, 0x70, 0x34, 0xf4, 0x1c,
	0x3e, 0x0f, 0x98, 0x70, 0x5b, 0xa6, 0x29, 0x43, 0xff, 0xeb, 0x26, 0xe4, 0xd1, 0x00, 0xa9, 0x02,
	0xb4, 0x8d, 0x5e, 0xf3, 0xbc, 0xdf, 0x6a, 0xf4, 0x1a, 0x9a, 0x42, 0x08, 0x54, 0x53, 0xba, 0x4f,
	0x8d, 0x17, 0x9a, 0xba, 0xc4, 0x6b, 0x34, 0x3b, 0x5a, 0x8e, 0x3c, 0x80, 0x5d, 0x6a, 0xbc, 0xb8,
	0x36, 0xec, 0x5e, 0xbf, 0x79, 0x6e, 0x34, 0x3b, 0xfd, 0x8b, 0xcb, 0x96, 0xd1, 0xd5, 0xf2, 0xe4,
	0x21, 0x3c, 0x58, 0x23, 0x10, 0xbb, 0x36, 0xc8, 0x36, 0x94, 0xb2, 0xda, 0x9b, 0x64, 0x17, 0xb6,
	0x97, 0xb5, 0x0a, 0x64, 0x1f, 0x76, 0x62, 0x13, 0xf4, 0xda, 0x92, 0xba, 0x5b, 0xe4, 0x13, 0xd8,
	0x5f, 0x61, 0x8b, 0x1d, 0x45, 0x72, 0x00, 0x84, 0x1a, 0xf6, 0xd5, 0xa5, 0x65, 0x1b, 0x99, 0x2d,
	0x40, 0x0e, 0xe1, 0x60, 0x95, 0x2f, 0xf6, 0x94, 0xc8, 0x0e, 0x54, 0x5e, 0x5c, 0x1b, 0xf4, 0x65,
	0x9f, 0x1a, 0xb6, 0x08, 0xb4, 0xbc, 0xc8, 0x42, 0xad, 0x8a, 0x40, 0xdc, 0xb0, 0x9a, 0x46, 0xb7,
	0xdf, 0x6b, 0xd8, 0x1d, 0xad, 0x2a, 0x10, 0xa7, 0x0c, 0xa1, 0xb5, 0x4d, 0x34, 0x28, 0x27, 0x41,
	0x37, 0xba, 0x5d, 0x4d, 0x23, 0x7b, 0xa0, 0x65, 0x39, 0x42, 0x6f, 0x07, 0x1d, 0x24, 0x78, 0x84,
	0x22, 0x89, 0x82, 0xcd, 0xb0, 0x84, 0xe6, 0x2e, 0x22, 0xb7, 0x8c, 0xde, 0x6f, 0x2e, 0x69, 0xa7,
	0x7f, 0xde, 0xb0, 0x5a, 0xf6, 0x79, 0xa3, 0x63, 0xf4, 0xaf, 0x4c, 0xeb, 0xb9, 0xb6, 0xf7, 0x16,
	0xd9, 0xa5, 0xf5, 0x5c, 0xdb, 0xc7, 0xef, 0x12, 0x7d, 0xab, 0x66, 0xf7, 0xda, 0xee, 0x19, 0xb4,
	0x6f, 0x5d, 0xb6, 0x0c, 0x5b, 0x3b, 0xc0, 0xef, 0xb2, 0x46, 0x80, 0x91, 0x6a, 0x0f, 0x44, 0x94,
	0x06, 0xed, 0xf5, 0xbf, 0x31, 0xa8, 0xd9, 0x7e, 0xa9, 0xd5, 0x10, 0x55, 0xac, 0xd7, 0x36, 0xbb,
	0x78, 0x1a, 0xad, 0x96, 0xf6, 0x09, 0x7e, 0x82, 0x15, 0xb6, 0x00, 0x7c, 0x88, 0x9f, 0x60, 0x51,
	0xd4, 0x6b, 0x74, 0x0c, 0xed, 0x21, 0x82, 0x5d, 0xe5, 0x8b, 0x3d, 0x8f, 0x48, 0x0d, 0xf6, 0x16,
	0x65, 0x2d, 0xa3, 0x6b, 0xf4, 0x0c, 0xed, 0x31, 0x79, 0x04, 0xb5, 0x75, 0x12, 0xb1, 0xef, 0x88,
	0xd4, 0xe1, 0x51, 0x9b, 0xb9, 0x2c, 0x70, 0x38, 0x73, 0x9b, 0xfe, 0x74, 0x36, 0xe7, 0x0e, 0xde,
	0xd8, 0x3e, 0x65, 0xbf, 0x9b, 0xb3, 0x90, 0x6b, 0x9f, 0x92, 0x27, 0xf0, 0xf8, 0x2d, 0x1a, 0xe1,
	0xcc, 0xf7, 0x42, 0xa6, 0xd5, 0xc9, 0x4f, 0xe1, 0xc7, 0x6b, 0x55, 0x4c, 0x8f, 0xb3, 0x60, 0xca,
	0xdc, 0x91, 0xc3, 0x59, 0x5f, 0x5e, 0x36, 0xed, 0x89, 0xfe, 0x39, 0x54, 0x28, 0x9b, 0xfa, 0x9c,
	0x49, 0x27, 0x6f, 0x2b, 0x33, 0xfa, 0x53, 0xa8, 0xc6, 0x8a, 0x91, 0x2f, 0x2c, 0x12, 0x01, 0x0b,
	0x65, 0x45, 0xc0, 0x65, 0x7a, 0xf1, 0x73, 0xd9, 0x8b, 0xff, 0x4f, 0x05, 0x76, 0xa4, 0xf5, 0xe6,
	0x2d, 0x1b, 0x8c, 0x2f, 0x7c, 0x97, 0x4d, 0xb0, 0x44, 0x71, 0x27, 0x1c, 0x9f, 0x3b, 0xe1, 0xad,
	0xf4, 0x94, 0xd0, 0xa2, 0x44, 0x39, 0x53, 0x26, 0x2e, 0x7e, 0x91, 0x8a, 0x35, 0xf2, 0xf8, 0x68,
	0xca, 0x44, 0x39, 0xcb, 0x51, 0xb1, 0x26, 0x75, 0x28, 0xb9, 0x2c, 0x1c, 0x04, 0xa3, 0x99, 0xa8,
	0x74, 0x79, 0xa1, 0x9e, 0x65, 0x91, 0x1a, 0x14, 0x06, 0x01, 0x73, 0xb8, 0x1f, 0xd4, 0x36, 0x84,
	0x34, 0x26, 0x11, 0xeb, 0x14, 0x81, 0xd4, 0x36, 0x45, 0x75, 0x89, 0x08, 0x2c, 0x2f, 0x62, 0x61,
	0xa1, 0xfb, 0x82, 0x90, 0xa4, 0x8c, 0xcc, 0xd9, 0x6c, 0x2d, 0x9c, 0xcd, 0x57, 0xb0, 0xb7, 0x12,
	0x20, 0x96, 0x51, 0x02, 0xf9, 0x81, 0xef, 0x46, 0x65, 0xae, 0x42, 0xc5, 0x1a, 0x4f, 0x8d, 0x05,
	0x81, 0x38, 0xb5, 0x22, 0xc5, 0xa5, 0xfe, 0x07, 0x80, 0x7b, 0x9e, 0x4b, 0x8c, 0x4e, 0x08, 0xa3,
	0xc3, 0x49, 0x19, 0x89, 0xb7, 0xdc, 0xa2, 0xb7, 0x69, 0x38, 0x94, 0x85, 0x18, 0x97, 0xb1, 0xff,
	0x8d, 0xd4, 0xff, 0x2f, 0xa0, 0xf2, 0x21, 0xb0, 0x7f, 0x0b, 0xd0, 0x74, 0xbc, 0x01, 0x9b, 0xf4,
	0x9c, 0x70, 0xfc, 0x4e, 0xd8, 0xe9, 0xb1, 0xa9, 0x0b, 0x2f, 0xd7, 0x42, 0x38, 0x51, 0xca, 0xa4,
	0x0c, 0x01, 0x2b, 0xb1, 0x7f, 0x7f, 0x58, 0x7d, 0xd8, 0x96, 0xdf, 0x82, 0xce, 0xbd, 0x8f, 0x70,
	0xa4, 0xe2, 0x6d, 0xcd, 0xa5, 0x6f, 0xab, 0xfe, 0x25, 0x90, 0x25, 0x07, 0xf7, 0x07, 0xf7, 0x47,
	0x05, 0xb4, 0xf8, 0xfe, 0x7c, 0x1c, 0x78, 0xeb, 0xbe, 0x38, 0xde, 0xca, 0x7c, 0x7a, 0x2b, 0x57,
	0xbf, 0xf8, 0x33, 0xd8, 0x5d, 0x46, 0x71, 0xff, 0x18, 0xa6, 0x50, 0x8a, 0x93, 0xdd, 0x99, 0x4c,
	0x3e, 0xe8, 0xc3, 0x1f, 0xc0, 0xe6, 0x94, 0xf1, 0x5b, 0xdf, 0x95, 0xcd, 0x89, 0xa4, 0x92, 0xe3,
	0xce, 0x67, 0x8e, 0xfb, 0x0b, 0xac, 0x3b, 0x89, 0xbb, 0xfb, 0xc3, 0xfc, 0x1e, 0xca, 0x71, 0x8c,
	0x1f, 0x8c, 0xf3, 0x43, 0xcf, 0xf7, 0x97, 0x98, 0x83, 0xa9, 0xef, 0xfb, 0x83, 0xfe, 0x19, 0x14,
	0xce, 0xbe, 0xbd, 0xb0, 0x50, 0x58, 0x05, 0x35, 0xe9, 0xc0, 0xd4, 0x91, 0x8b, 0xf5, 0xca, 0x71,
	0xdd, 0x00, 0xeb, 0x6d, 0x0e, 0x6b, 0xab, 0x20, 0xf4, 0x5f, 0xc1, 0x96, 0xdc, 0x20, 0x70, 0x0c,
	0xd3, 0xa6, 0x6d, 0x38, 0x72, 0xc9, 0x13, 0xd8, 0xf0, 0x50, 0x24, 0xf6, 0x94, 0x4e, 0x4b, 0xd8,
	0x67, 0x49, 0x75, 0x1a, 0x49, 0xf4, 0x4f, 0xa1, 0x82, 0xe4, 0xf3, 0xc0, 0x9f, 0xcf, 0x4c, 0xef,
	0x3b, 0x7f, 0xd9, 0xaf, 0xfe, 0x14, 0xb6, 0x28, 0x0b, 0x5f, 0xcc, 0x59, 0x70, 0x87, 0xd5, 0xf4,
	0x15, 0x0b, 0x42, 0xac, 0xb5, 0x91, 0x42, 0x4c, 0x8a, 0x56, 0x6d, 0x6a, 0xb6, 0xe2, 0x8a, 0x8d,
	0x6b, 0xfd, 0xef, 0x0a, 0x66, 0x4a, 0xb4, 0x15, 0x8f, 0xe0, 0xbd, 0x76, 0x93, 0xcf, 0xa0, 0xe2,
	0x8e, 0xc2, 0x71, 0xcf, 0xe7, 0xce, 0xc4, 0x1e, 0x7d, 0x1f, 0x7d, 0x84, 0x3c, 0x5d, 0x64, 0x12,
	0x1d, 0xca, 0xc8, 0xa0, 0x2c, 0xe4, 0x42, 0x29, 0x2f, 0x94, 0x16, 0x78, 0xf8, 0x75, 0x07, 0xb3,
	0xb9, 0x35, 0x9f, 0x8a, 0x27, 0xa0, 0x42, 0x25, 0x15, 0x65, 0xe1, 0xd4, 0x0f, 0xee, 0xc4, 0x13,
	0x90, 0xa7, 0x92, 0x4a, 0x5f, 0xb1, 0x42, 0xf6, 0x15, 0x1b, 0xc2, 0x76, 0x73, 0x32, 0x0f, 0x39,
	0x0b, 0xda, 0xa3, 0x09, 0x0b, 0x1b, 0xae, 0xfb, 0x8e, 0x80, 0x64, 0xff, 0xac, 0xae, 0xf6, 0xcf,
	0xb2, 0x92, 0x88, 0xfe, 0x79, 0x7d, 0x9f, 0xdc, 0x02, 0xb2, 0xe4, 0xe8, 0xdd, 0x87, 0x97, 0x58,
	0x51, 0xb3, 0x56, 0xbe, 0x06, 0x2d, 0x6b, 0xa5, 0xe7, 0x8c, 0xd9, 0xfb, 0xe0, 0xd5, 0xc7, 0xb0,
	0xbb, 0xbc, 0xff, 0xdd, 0x30, 0x7e, 0x48, 0xc8, 0xbf, 0x5e, 0x0c, 0xb9, 0xc5, 0x26, 0x8c, 0xbf,
	0x1f, 0xdc, 0x97, 0xb0, 0xbf, 0x6a, 0xe1, 0x7d, 0x01, 0xaf, 0x6f, 0x5f, 0xfe, 0xa2, 0x42, 0xb1,
	0xdd, 0x8c, 0xdb, 0x23, 0x02, 0xf9, 0x76, 0xd3, 0x6c, 0x49, 0x63, 0x62, 0x8d, 0x89, 0x84, 0xa5,
	0x24, 0x49, 0x60, 0x49, 0x89, 0xc4, 0x73, 0x26, 0x13, 0x16, 0xc4, 0x65, 0x2e, 0xa2, 0x90, 0xff,
	0x6a, 0x8a, 0x63, 0x8a, 0x9c, 0xc1, 0x24, 0x45, 0xbe, 0x82, 0x2a, 0x7b, 0xcd, 0x06, 0x73, 0xce,
	0x9a, 0xbe, 0xc7, 0x99, 0xc7, 0x45, 0xc2, 0x96, 0x4e, 0xf7, 0xf0, 0xde, 0xb6, 0x9b, 0xc6, 0x82,
	0x8c, 0x2e, 0xe9, 0x92, 0x63, 0x39, 0x53, 0x6d, 0x8a, 0x99, 0x4a, 0xee, 0x91, 0xb0, 0x4f, 0xda,
	0xcd, 0xcc, 0x5c, 0x75, 0x08, 0x5b, 0xec, 0x35, 0x67, 0x81, 0xe7, 0x4c, 0x44, 0x8e, 0x97, 0x69,
	0x42, 0xeb, 0xcf, 0x60, 0x33, 0xd2, 0xc5, 0xa6, 0xde, 0xba, 0xa4, 0x17, 0x8d, 0x6e, 0xdf, 0xb4,
	0xbe, 0xb9, 0xec, 0x18, 0x9a, 0x82, 0x53, 0xd5, 0x95, 0xdd, 0x88, 0x69, 0x35, 0xa2, 0xcd, 0x98,
	0xce, 0xe9, 0xff, 0x53, 0x60, 0xe7, 0xca, 0x6e, 0x98, 0xde, 0x2b, 0x7f, 0xcc, 0x0c, 0x69, 0x92,
	0xf4, 0x60, 0xfb, 0xca, 0x09, 0xf8, 0x68, 0x30, 0x9a, 0x39, 0x1e, 0xef, 0x8e, 0x42, 0x5e, 0x53,
	0x44, 0x3d, 0xfa, 0x09, 0x62, 0x5c, 0xd1, 0x3f, 0x59, 0x52, 0x36, 0x3c, 0x1e, 0xdc, 0xd1, 0x65,
	0x13, 0xe4, 0xe7, 0x32, 0x5c, 0x55, 0x84, 0xfb, 0xf8, 0x2d, 0xa6, 0xec, 0x46, 0x1a, 0xf7, 0xe1,
	0x19, 0xec, 0xad, 0xb3, 0x8d, 0x99, 0x30, 0x16, 0xfd, 0xae, 0x72, 0x5c, 0xa1, 0xb8, 0xc4, 0x4c,
	0x78, 0xe5, 0x4c, 0xe6, 0x2c, 0xbe, 0x53, 0x82, 0xf8, 0x52, 0x7d, 0xaa, 0xe8, 0x0f, 0xa1, 0x20,
	0x8d, 0x92, 0x02, 0xe4, 0x70, 0x7c, 0x50, 0x70, 0x61, 0x5f, 0x9f, 0x69, 0xaa, 0xfe, 0x0c, 0xc3,
	0x37, 0x97, 0xc2, 0xaf, 0x41, 0xc1, 0x66, 0x51, 0x75, 0x8a, 0x8a, 0x7f, 0x4c, 0x92, 0x32, 0x28,
	0x96, 0x1c, 0x6e, 0x15, 0x4b, 0x9f, 0x81, 0xb6, 0xfc, 0x8d, 0x71, 0xaf, 0x78, 0xed, 0x93, 0x84,
	0x8b, 0xc9, 0x8f, 0xf2, 0xb4, 0x7e, 0x0b, 0x80, 0x19, 0x22, 0xdb, 0xf9, 0x75, 0x99, 0x1d, 0xbf,
	0x5a, 0xea, 0xea, 0x03, 0x98, 0x5b, 0x79, 0x00, 0xf3, 0xe9, 0x3b, 0xf6, 0x1f, 0x15, 0xf6, 0xdb,
	0xcd, 0xec, 0xc8, 0x11, 0x4f, 0xfe, 0xeb, 0xbc, 0x9c, 0x2e, 0x7c, 0xca, 0xa3, 0x28, 0x73, 0xd7,
	0x6c, 0x5e, 0xf7, 0x6f, 0x20, 0x97, 0xfe, 0x1b, 0xd0, 0xff, 0xab, 0xc8, 0xe9, 0x7f, 0x1b, 0x4a,
	0x1d, 0x03, 0xc7, 0x5d, 0x31, 0xa9, 0x6a, 0x0a, 0x0e, 0xb2, 0x11, 0x23, 0x9a, 0x48, 0xa3, 0xd4,
	0x45, 0xce, 0xf5, 0x55, 0xab, 0xd1, 0x33, 0xb4, 0x1c, 0x21, 0x50, 0x4d, 0x69, 0x31, 0x8f, 0xe5,
	0x71, 0x5a, 0xcc, 0xf0, 0xda, 0xa6, 0x65, 0xda, 0xe7, 0xda, 0x06, 0x8e, 0xca, 0x51, 0xd6, 0x9b,
	0xbd, 0x98, 0xb9, 0x89, 0x03, 0xea, 0x12, 0x53, 0x4e, 0xfd, 0x7b, 0xa0, 0xa1, 0xe0, 0x02, 0xa7,
	0xea, 0x18, 0xd0, 0x16, 0x8e, 0x8f, 0x19, 0xae, 0x9c, 0x93, 0x71, 0xb3, 0x56, 0x24, 0x47, 0x70,
	0xb8, 0x5e, 0x26, 0x2c, 0x02, 0xc2, 0x5a, 0x91, 0x6b, 0x25, 0xdd, 0x02, 0x72, 0x65, 0x9b, 0x17,
	0x0e, 0xbe, 0x7c, 0xe2, 0xd2, 0x9f, 0xf9, 0xee, 0x1d, 0x8e, 0x48, 0x36, 0x77, 0x02, 0x6e, 0xcd,
	0xa7, 0x37, 0x2c, 0x90, 0x19, 0x98, 0x65, 0x61, 0xc6, 0xd8, 0xf3, 0x1b, 0x9b, 0x71, 0xd1, 0x25,
	0x94, 0xa9, 0xa4, 0xf4, 0x97, 0xf0, 0x20, 0xb1, 0x17, 0xa5, 0x88, 0xe9, 0x8d, 0x12, 0xa3, 0xd4,
	0x9f, 0x7b, 0xee, 0xa2, 0xd1, 0x0c, 0x0b, 0xfb, 0xd6, 0x9e, 0x73, 0x33, 0x61, 0x22, 0xed, 0xa3,
	0xec, 0x49, 0x19, 0xfa, 0xd7, 0xe2, 0xb0, 0xb2, 0xa6, 0x85, 0xd9, 0xcf, 0xa1, 0x70, 0x36, 0x1f,
	0x8c, 0x19, 0x0f, 0x65, 0x81, 0xa8, 0x44, 0xb7, 0xda, 0x8c, 0xb8, 0x34, 0x96, 0xea, 0x06, 0x14,
	0x13, 0x2e, 0xe2, 0x5f, 0xc0, 0x21, 0x29, 0x52, 0x87, 0x5c, 0x1c, 0x54, 0xe9, 0xb4, 0x2a, 0x2d,
	0xd9, 0x8c, 0xb7, 0x1c, 0xee, 0x50, 0x14, 0xe9, 0x5f, 0x88, 0xf2, 0x25, 0x59, 0x78, 0xe7, 0x4d,
	0xcf, 0x65, 0xaf, 0xa5, 0x99, 0x88, 0xc0, 0x3c, 0x6b, 0x45, 0xff, 0xbd, 0x44, 0x9e, 0xe1, 0xfa,
	0x4c, 0xfb, 0xdb, 0x9b, 0x23, 0xe5, 0x1f, 0x6f, 0x8e, 0x94, 0x7f, 0xbd, 0x39, 0x52, 0xfe, 0xfc,
	0xef, 0xa3, 0x1f, 0xfd, 0x3f, 0x00, 0x00, 0xff, 0xff, 0x37, 0x07, 0x9b, 0xd7, 0xbc, 0x13, 0x00,
	0x00,
}

func (m *FetchData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FetchData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FetchData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.NRet == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i = encodeVarintNetwork(dAtA, i, uint64(*m.NRet))
		i--
		dAtA[i] = 0x20
	}
	if m.Function == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i -= len(*m.Function)
		copy(dAtA[i:], *m.Function)
		i = encodeVarintNetwork(dAtA, i, uint64(len(*m.Function)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Args == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i -= len(m.Args)
		copy(dAtA[i:], m.Args)
		i = encodeVarintNetwork(dAtA, i, uint64(len(m.Args)))
		i--
		dAtA[i] = 0x12
	}
	if m.AppKey == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i -= len(*m.AppKey)
		copy(dAtA[i:], *m.AppKey)
		i = encodeVarintNetwork(dAtA, i, uint64(len(*m.AppKey)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FetchDataACK) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FetchDataACK) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FetchDataACK) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Error != nil {
		i -= len(*m.Error)
		copy(dAtA[i:], *m.Error)
		i = encodeVarintNetwork(dAtA, i, uint64(len(*m.Error)))
		i--
		dAtA[i] = 0x22
	}
	if m.Length != nil {
		i = encodeVarintNetwork(dAtA, i, uint64(*m.Length))
		i--
		dAtA[i] = 0x18
	}
	if m.Data != nil {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintNetwork(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x12
	}
	if m.Did == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i -= len(*m.Did)
		copy(dAtA[i:], *m.Did)
		i = encodeVarintNetwork(dAtA, i, uint64(len(*m.Did)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Message) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Message) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Message) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Signature != nil {
		i -= len(m.Signature)
		copy(dAtA[i:], m.Signature)
		i = encodeVarintNetwork(dAtA, i, uint64(len(m.Signature)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Body == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i -= len(m.Body)
		copy(dAtA[i:], m.Body)
		i = encodeVarintNetwork(dAtA, i, uint64(len(m.Body)))
		i--
		dAtA[i] = 0x12
	}
	if m.Type == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i = encodeVarintNetwork(dAtA, i, uint64(*m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RemoteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RemoteRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RemoteRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.AppKey == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i -= len(*m.AppKey)
		copy(dAtA[i:], *m.AppKey)
		i = encodeVarintNetwork(dAtA, i, uint64(len(*m.AppKey)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RemoteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RemoteResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RemoteResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Error != nil {
		i -= len(*m.Error)
		copy(dAtA[i:], *m.Error)
		i = encodeVarintNetwork(dAtA, i, uint64(len(*m.Error)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Res != nil {
		i -= len(m.Res)
		copy(dAtA[i:], m.Res)
		i = encodeVarintNetwork(dAtA, i, uint64(len(m.Res)))
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *RequestCheckModel) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RequestCheckModel) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestCheckModel) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.AppKey == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i -= len(*m.AppKey)
		copy(dAtA[i:], *m.AppKey)
		i = encodeVarintNetwork(dAtA, i, uint64(len(*m.AppKey)))
		i--
		dAtA[i] = 0x42
	}
	if m.ModelName == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i -= len(m.ModelName)
		copy(dAtA[i:], m.ModelName)
		i = encodeVarintNetwork(dAtA, i, uint64(len(m.ModelName)))
		i--
		dAtA[i] = 0x3a
	}
	if m.Model == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i -= len(m.Model)
		copy(dAtA[i:], m.Model)
		i = encodeVarintNetwork(dAtA, i, uint64(len(m.Model)))
		i--
		dAtA[i] = 0x32
	}
	if m.Creator == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i -= len(*m.Creator)
		copy(dAtA[i:], *m.Creator)
		i = encodeVarintNetwork(dAtA, i, uint64(len(*m.Creator)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Description == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i -= len(*m.Description)
		copy(dAtA[i:], *m.Description)
		i = encodeVarintNetwork(dAtA, i, uint64(len(*m.Description)))
		i--
		dAtA[i] = 0x22
	}
	if m.Time == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i = encodeVarintNetwork(dAtA, i, uint64(*m.Time))
		i--
		dAtA[i] = 0x18
	}
	if m.Name == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i -= len(*m.Name)
		copy(dAtA[i:], *m.Name)
		i = encodeVarintNetwork(dAtA, i, uint64(len(*m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.TaskHash == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i -= len(*m.TaskHash)
		copy(dAtA[i:], *m.TaskHash)
		i = encodeVarintNetwork(dAtA, i, uint64(len(*m.TaskHash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RequestCheckModelACK) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RequestCheckModelACK) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestCheckModelACK) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Err != nil {
		i -= len(*m.Err)
		copy(dAtA[i:], *m.Err)
		i = encodeVarintNetwork(dAtA, i, uint64(len(*m.Err)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i = encodeVarintNetwork(dAtA, i, uint64(*m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CheckModel) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CheckModel) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CheckModel) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Err != nil {
		i -= len(*m.Err)
		copy(dAtA[i:], *m.Err)
		i = encodeVarintNetwork(dAtA, i, uint64(len(*m.Err)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Msg != nil {
		i -= len(*m.Msg)
		copy(dAtA[i:], *m.Msg)
		i = encodeVarintNetwork(dAtA, i, uint64(len(*m.Msg)))
		i--
		dAtA[i] = 0x22
	}
	if m.Code == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i = encodeVarintNetwork(dAtA, i, uint64(*m.Code))
		i--
		dAtA[i] = 0x18
	}
	if m.ModelHash == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i -= len(*m.ModelHash)
		copy(dAtA[i:], *m.ModelHash)
		i = encodeVarintNetwork(dAtA, i, uint64(len(*m.ModelHash)))
		i--
		dAtA[i] = 0x12
	}
	if m.TaskHash == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i -= len(*m.TaskHash)
		copy(dAtA[i:], *m.TaskHash)
		i = encodeVarintNetwork(dAtA, i, uint64(len(*m.TaskHash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CheckModelACK) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CheckModelACK) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CheckModelACK) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Err != nil {
		i -= len(*m.Err)
		copy(dAtA[i:], *m.Err)
		i = encodeVarintNetwork(dAtA, i, uint64(len(*m.Err)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i = encodeVarintNetwork(dAtA, i, uint64(*m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CancelTask) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CancelTask) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CancelTask) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ModelHash != nil {
		i -= len(*m.ModelHash)
		copy(dAtA[i:], *m.ModelHash)
		i = encodeVarintNetwork(dAtA, i, uint64(len(*m.ModelHash)))
		i--
		dAtA[i] = 0x1a
	}
	if m.AppKey == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i -= len(*m.AppKey)
		copy(dAtA[i:], *m.AppKey)
		i = encodeVarintNetwork(dAtA, i, uint64(len(*m.AppKey)))
		i--
		dAtA[i] = 0x12
	}
	if m.TaskHash == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i -= len(*m.TaskHash)
		copy(dAtA[i:], *m.TaskHash)
		i = encodeVarintNetwork(dAtA, i, uint64(len(*m.TaskHash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CancelTaskACK) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CancelTaskACK) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CancelTaskACK) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Err != nil {
		i -= len(*m.Err)
		copy(dAtA[i:], *m.Err)
		i = encodeVarintNetwork(dAtA, i, uint64(len(*m.Err)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i = encodeVarintNetwork(dAtA, i, uint64(*m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RequestRunModel) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RequestRunModel) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestRunModel) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Args == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i -= len(m.Args)
		copy(dAtA[i:], m.Args)
		i = encodeVarintNetwork(dAtA, i, uint64(len(m.Args)))
		i--
		dAtA[i] = 0x1a
	}
	if m.ModelHash == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i -= len(*m.ModelHash)
		copy(dAtA[i:], *m.ModelHash)
		i = encodeVarintNetwork(dAtA, i, uint64(len(*m.ModelHash)))
		i--
		dAtA[i] = 0x12
	}
	if m.TaskHash == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i -= len(*m.TaskHash)
		copy(dAtA[i:], *m.TaskHash)
		i = encodeVarintNetwork(dAtA, i, uint64(len(*m.TaskHash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RequestRunModelACK) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RequestRunModelACK) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestRunModelACK) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Err != nil {
		i -= len(*m.Err)
		copy(dAtA[i:], *m.Err)
		i = encodeVarintNetwork(dAtA, i, uint64(len(*m.Err)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i = encodeVarintNetwork(dAtA, i, uint64(*m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ResponseRunModel) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResponseRunModel) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponseRunModel) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Err != nil {
		i -= len(*m.Err)
		copy(dAtA[i:], *m.Err)
		i = encodeVarintNetwork(dAtA, i, uint64(len(*m.Err)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Res != nil {
		i -= len(m.Res)
		copy(dAtA[i:], m.Res)
		i = encodeVarintNetwork(dAtA, i, uint64(len(m.Res)))
		i--
		dAtA[i] = 0x22
	}
	if m.Code == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i = encodeVarintNetwork(dAtA, i, uint64(*m.Code))
		i--
		dAtA[i] = 0x18
	}
	if m.ModelHash == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i -= len(*m.ModelHash)
		copy(dAtA[i:], *m.ModelHash)
		i = encodeVarintNetwork(dAtA, i, uint64(len(*m.ModelHash)))
		i--
		dAtA[i] = 0x12
	}
	if m.TaskHash == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i -= len(*m.TaskHash)
		copy(dAtA[i:], *m.TaskHash)
		i = encodeVarintNetwork(dAtA, i, uint64(len(*m.TaskHash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ResponseRunModelACK) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResponseRunModelACK) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponseRunModelACK) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Err != nil {
		i -= len(*m.Err)
		copy(dAtA[i:], *m.Err)
		i = encodeVarintNetwork(dAtA, i, uint64(len(*m.Err)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i = encodeVarintNetwork(dAtA, i, uint64(*m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RequestCall) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RequestCall) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestCall) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Args == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i -= len(m.Args)
		copy(dAtA[i:], m.Args)
		i = encodeVarintNetwork(dAtA, i, uint64(len(m.Args)))
		i--
		dAtA[i] = 0x22
	}
	if m.Method == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i -= len(*m.Method)
		copy(dAtA[i:], *m.Method)
		i = encodeVarintNetwork(dAtA, i, uint64(len(*m.Method)))
		i--
		dAtA[i] = 0x1a
	}
	if m.AppKey == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i -= len(*m.AppKey)
		copy(dAtA[i:], *m.AppKey)
		i = encodeVarintNetwork(dAtA, i, uint64(len(*m.AppKey)))
		i--
		dAtA[i] = 0x12
	}
	if m.TaskHash == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i -= len(*m.TaskHash)
		copy(dAtA[i:], *m.TaskHash)
		i = encodeVarintNetwork(dAtA, i, uint64(len(*m.TaskHash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RequestCallACK) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RequestCallACK) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestCallACK) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Err != nil {
		i -= len(*m.Err)
		copy(dAtA[i:], *m.Err)
		i = encodeVarintNetwork(dAtA, i, uint64(len(*m.Err)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i = encodeVarintNetwork(dAtA, i, uint64(*m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ResponseCall) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResponseCall) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponseCall) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Err != nil {
		i -= len(*m.Err)
		copy(dAtA[i:], *m.Err)
		i = encodeVarintNetwork(dAtA, i, uint64(len(*m.Err)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Res != nil {
		i -= len(m.Res)
		copy(dAtA[i:], m.Res)
		i = encodeVarintNetwork(dAtA, i, uint64(len(m.Res)))
		i--
		dAtA[i] = 0x22
	}
	if m.Code == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i = encodeVarintNetwork(dAtA, i, uint64(*m.Code))
		i--
		dAtA[i] = 0x18
	}
	if m.AppKey == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i -= len(*m.AppKey)
		copy(dAtA[i:], *m.AppKey)
		i = encodeVarintNetwork(dAtA, i, uint64(len(*m.AppKey)))
		i--
		dAtA[i] = 0x12
	}
	if m.TaskHash == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i -= len(*m.TaskHash)
		copy(dAtA[i:], *m.TaskHash)
		i = encodeVarintNetwork(dAtA, i, uint64(len(*m.TaskHash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ResponseCallACK) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResponseCallACK) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponseCallACK) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Err != nil {
		i -= len(*m.Err)
		copy(dAtA[i:], *m.Err)
		i = encodeVarintNetwork(dAtA, i, uint64(len(*m.Err)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i = encodeVarintNetwork(dAtA, i, uint64(*m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BXMNode) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BXMNode) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BXMNode) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Addrs) > 0 {
		for iNdEx := len(m.Addrs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Addrs[iNdEx])
			copy(dAtA[i:], m.Addrs[iNdEx])
			i = encodeVarintNetwork(dAtA, i, uint64(len(m.Addrs[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Id == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i -= len(*m.Id)
		copy(dAtA[i:], *m.Id)
		i = encodeVarintNetwork(dAtA, i, uint64(len(*m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BXMNodes) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BXMNodes) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BXMNodes) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Nodes) > 0 {
		for iNdEx := len(m.Nodes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Nodes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintNetwork(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Gid == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i -= len(*m.Gid)
		copy(dAtA[i:], *m.Gid)
		i = encodeVarintNetwork(dAtA, i, uint64(len(*m.Gid)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NodeGroupInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeGroupInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NodeGroupInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Id == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i -= len(*m.Id)
		copy(dAtA[i:], *m.Id)
		i = encodeVarintNetwork(dAtA, i, uint64(len(*m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ResQuery) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResQuery) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResQuery) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.BmID == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i -= len(*m.BmID)
		copy(dAtA[i:], *m.BmID)
		i = encodeVarintNetwork(dAtA, i, uint64(len(*m.BmID)))
		i--
		dAtA[i] = 0x12
	}
	if m.Version == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i -= len(*m.Version)
		copy(dAtA[i:], *m.Version)
		i = encodeVarintNetwork(dAtA, i, uint64(len(*m.Version)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ResQueryACK) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResQueryACK) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResQueryACK) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Error != nil {
		i -= len(*m.Error)
		copy(dAtA[i:], *m.Error)
		i = encodeVarintNetwork(dAtA, i, uint64(len(*m.Error)))
		i--
		dAtA[i] = 0x3a
	}
	if m.Memory == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i = encodeVarintNetwork(dAtA, i, uint64(*m.Memory))
		i--
		dAtA[i] = 0x30
	}
	if m.CpuNum == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i = encodeVarintNetwork(dAtA, i, uint64(*m.CpuNum))
		i--
		dAtA[i] = 0x28
	}
	if m.DiskRestSize == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i = encodeVarintNetwork(dAtA, i, uint64(*m.DiskRestSize))
		i--
		dAtA[i] = 0x20
	}
	if m.DiskTotalSize == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i = encodeVarintNetwork(dAtA, i, uint64(*m.DiskTotalSize))
		i--
		dAtA[i] = 0x18
	}
	if m.BmID == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i -= len(*m.BmID)
		copy(dAtA[i:], *m.BmID)
		i = encodeVarintNetwork(dAtA, i, uint64(len(*m.BmID)))
		i--
		dAtA[i] = 0x12
	}
	if m.Version == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i -= len(*m.Version)
		copy(dAtA[i:], *m.Version)
		i = encodeVarintNetwork(dAtA, i, uint64(len(*m.Version)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ClusterFilesAdd) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClusterFilesAdd) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClusterFilesAdd) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Error != nil {
		i -= len(*m.Error)
		copy(dAtA[i:], *m.Error)
		i = encodeVarintNetwork(dAtA, i, uint64(len(*m.Error)))
		i--
		dAtA[i] = 0x22
	}
	if m.Data == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintNetwork(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Did == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i -= len(*m.Did)
		copy(dAtA[i:], *m.Did)
		i = encodeVarintNetwork(dAtA, i, uint64(len(*m.Did)))
		i--
		dAtA[i] = 0x12
	}
	if m.Version == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i -= len(*m.Version)
		copy(dAtA[i:], *m.Version)
		i = encodeVarintNetwork(dAtA, i, uint64(len(*m.Version)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ClusterFilesAddACK) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClusterFilesAddACK) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClusterFilesAddACK) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Error != nil {
		i -= len(*m.Error)
		copy(dAtA[i:], *m.Error)
		i = encodeVarintNetwork(dAtA, i, uint64(len(*m.Error)))
		i--
		dAtA[i] = 0x12
	}
	if m.Version == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i -= len(*m.Version)
		copy(dAtA[i:], *m.Version)
		i = encodeVarintNetwork(dAtA, i, uint64(len(*m.Version)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ClusterFilesTake) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClusterFilesTake) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClusterFilesTake) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Did == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i -= len(*m.Did)
		copy(dAtA[i:], *m.Did)
		i = encodeVarintNetwork(dAtA, i, uint64(len(*m.Did)))
		i--
		dAtA[i] = 0x12
	}
	if m.Version == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i -= len(*m.Version)
		copy(dAtA[i:], *m.Version)
		i = encodeVarintNetwork(dAtA, i, uint64(len(*m.Version)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ClusterFilesTakeACK) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClusterFilesTakeACK) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClusterFilesTakeACK) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Error != nil {
		i -= len(*m.Error)
		copy(dAtA[i:], *m.Error)
		i = encodeVarintNetwork(dAtA, i, uint64(len(*m.Error)))
		i--
		dAtA[i] = 0x22
	}
	if m.Data == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintNetwork(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Did == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i -= len(*m.Did)
		copy(dAtA[i:], *m.Did)
		i = encodeVarintNetwork(dAtA, i, uint64(len(*m.Did)))
		i--
		dAtA[i] = 0x12
	}
	if m.Version == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i -= len(*m.Version)
		copy(dAtA[i:], *m.Version)
		i = encodeVarintNetwork(dAtA, i, uint64(len(*m.Version)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ClusterFilesDelete) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClusterFilesDelete) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClusterFilesDelete) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Did == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i -= len(*m.Did)
		copy(dAtA[i:], *m.Did)
		i = encodeVarintNetwork(dAtA, i, uint64(len(*m.Did)))
		i--
		dAtA[i] = 0x12
	}
	if m.Version == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i -= len(*m.Version)
		copy(dAtA[i:], *m.Version)
		i = encodeVarintNetwork(dAtA, i, uint64(len(*m.Version)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ClusterFilesDeleteACK) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClusterFilesDeleteACK) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClusterFilesDeleteACK) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Error != nil {
		i -= len(*m.Error)
		copy(dAtA[i:], *m.Error)
		i = encodeVarintNetwork(dAtA, i, uint64(len(*m.Error)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Did == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i -= len(*m.Did)
		copy(dAtA[i:], *m.Did)
		i = encodeVarintNetwork(dAtA, i, uint64(len(*m.Did)))
		i--
		dAtA[i] = 0x12
	}
	if m.Version == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i -= len(*m.Version)
		copy(dAtA[i:], *m.Version)
		i = encodeVarintNetwork(dAtA, i, uint64(len(*m.Version)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FCRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FCRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FCRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.External != nil {
		i -= len(m.External)
		copy(dAtA[i:], m.External)
		i = encodeVarintNetwork(dAtA, i, uint64(len(m.External)))
		i--
		dAtA[i] = 0x3a
	}
	if m.Type == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i = encodeVarintNetwork(dAtA, i, uint64(*m.Type))
		i--
		dAtA[i] = 0x30
	}
	if m.ExecuteContent == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		{
			size, err := m.ExecuteContent.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNetwork(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.VmType == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i = encodeVarintNetwork(dAtA, i, uint64(*m.VmType))
		i--
		dAtA[i] = 0x20
	}
	if m.Caller == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i -= len(*m.Caller)
		copy(dAtA[i:], *m.Caller)
		i = encodeVarintNetwork(dAtA, i, uint64(len(*m.Caller)))
		i--
		dAtA[i] = 0x1a
	}
	if m.TaskID == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i -= len(*m.TaskID)
		copy(dAtA[i:], *m.TaskID)
		i = encodeVarintNetwork(dAtA, i, uint64(len(*m.TaskID)))
		i--
		dAtA[i] = 0x12
	}
	if m.FCID == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i -= len(*m.FCID)
		copy(dAtA[i:], *m.FCID)
		i = encodeVarintNetwork(dAtA, i, uint64(len(*m.FCID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PSAInvokeExternal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PSAInvokeExternal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PSAInvokeExternal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Type == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i = encodeVarintNetwork(dAtA, i, uint64(*m.Type))
		i--
		dAtA[i] = 0x10
	}
	if len(m.ParticipantList) > 0 {
		for k := range m.ParticipantList {
			v := m.ParticipantList[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintNetwork(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i = encodeVarintNetwork(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintNetwork(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *PSIInvokeExternal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PSIInvokeExternal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PSIInvokeExternal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.N == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i -= len(m.N)
		copy(dAtA[i:], m.N)
		i = encodeVarintNetwork(dAtA, i, uint64(len(m.N)))
		i--
		dAtA[i] = 0x12
	}
	if m.SetSize == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i = encodeVarintNetwork(dAtA, i, uint64(*m.SetSize))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FCExecuteContent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FCExecuteContent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FCExecuteContent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Args == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i -= len(m.Args)
		copy(dAtA[i:], m.Args)
		i = encodeVarintNetwork(dAtA, i, uint64(len(m.Args)))
		i--
		dAtA[i] = 0x22
	}
	if m.Method == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i -= len(*m.Method)
		copy(dAtA[i:], *m.Method)
		i = encodeVarintNetwork(dAtA, i, uint64(len(*m.Method)))
		i--
		dAtA[i] = 0x1a
	}
	if m.AppKey == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i -= len(*m.AppKey)
		copy(dAtA[i:], *m.AppKey)
		i = encodeVarintNetwork(dAtA, i, uint64(len(*m.AppKey)))
		i--
		dAtA[i] = 0x12
	}
	if m.ModelID == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i -= len(*m.ModelID)
		copy(dAtA[i:], *m.ModelID)
		i = encodeVarintNetwork(dAtA, i, uint64(len(*m.ModelID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FCResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FCResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FCResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Err != nil {
		i -= len(*m.Err)
		copy(dAtA[i:], *m.Err)
		i = encodeVarintNetwork(dAtA, i, uint64(len(*m.Err)))
		i--
		dAtA[i] = 0x22
	}
	if m.Res != nil {
		i -= len(m.Res)
		copy(dAtA[i:], m.Res)
		i = encodeVarintNetwork(dAtA, i, uint64(len(m.Res)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Code == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i = encodeVarintNetwork(dAtA, i, uint64(*m.Code))
		i--
		dAtA[i] = 0x10
	}
	if m.FCID == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i -= len(*m.FCID)
		copy(dAtA[i:], *m.FCID)
		i = encodeVarintNetwork(dAtA, i, uint64(len(*m.FCID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FCIntermediateMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FCIntermediateMessage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FCIntermediateMessage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Body == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i -= len(m.Body)
		copy(dAtA[i:], m.Body)
		i = encodeVarintNetwork(dAtA, i, uint64(len(m.Body)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Type == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i = encodeVarintNetwork(dAtA, i, uint64(*m.Type))
		i--
		dAtA[i] = 0x10
	}
	if m.FCID == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i -= len(*m.FCID)
		copy(dAtA[i:], *m.FCID)
		i = encodeVarintNetwork(dAtA, i, uint64(len(*m.FCID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PSIMaskRequestBody) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PSIMaskRequestBody) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PSIMaskRequestBody) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.SubSet) > 0 {
		for iNdEx := len(m.SubSet) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.SubSet[iNdEx])
			copy(dAtA[i:], m.SubSet[iNdEx])
			i = encodeVarintNetwork(dAtA, i, uint64(len(m.SubSet[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.StartNumber == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i = encodeVarintNetwork(dAtA, i, uint64(*m.StartNumber))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PSIMaskResponseInitBody) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PSIMaskResponseInitBody) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PSIMaskResponseInitBody) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.TableSize == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i = encodeVarintNetwork(dAtA, i, uint64(*m.TableSize))
		i--
		dAtA[i] = 0x10
	}
	if m.RoundNumber == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i = encodeVarintNetwork(dAtA, i, uint64(*m.RoundNumber))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PSIMaskResponseBody) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PSIMaskResponseBody) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PSIMaskResponseBody) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Buckets) > 0 {
		for iNdEx := len(m.Buckets) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Buckets[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintNetwork(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *PSIBucket) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PSIBucket) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PSIBucket) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Set) > 0 {
		for iNdEx := len(m.Set) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Set[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintNetwork(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Number == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i = encodeVarintNetwork(dAtA, i, uint64(*m.Number))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PSISetData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PSISetData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PSISetData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Data == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintNetwork(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x12
	}
	if m.Index == nil {
		return 0, new(github_com_golang_protobuf_proto.RequiredNotSetError)
	} else {
		i = encodeVarintNetwork(dAtA, i, uint64(*m.Index))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintNetwork(dAtA []byte, offset int, v uint64) int {
	offset -= sovNetwork(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *FetchData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AppKey != nil {
		l = len(*m.AppKey)
		n += 1 + l + sovNetwork(uint64(l))
	}
	if m.Args != nil {
		l = len(m.Args)
		n += 1 + l + sovNetwork(uint64(l))
	}
	if m.Function != nil {
		l = len(*m.Function)
		n += 1 + l + sovNetwork(uint64(l))
	}
	if m.NRet != nil {
		n += 1 + sovNetwork(uint64(*m.NRet))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FetchDataACK) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Did != nil {
		l = len(*m.Did)
		n += 1 + l + sovNetwork(uint64(l))
	}
	if m.Data != nil {
		l = len(m.Data)
		n += 1 + l + sovNetwork(uint64(l))
	}
	if m.Length != nil {
		n += 1 + sovNetwork(uint64(*m.Length))
	}
	if m.Error != nil {
		l = len(*m.Error)
		n += 1 + l + sovNetwork(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Message) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != nil {
		n += 1 + sovNetwork(uint64(*m.Type))
	}
	if m.Body != nil {
		l = len(m.Body)
		n += 1 + l + sovNetwork(uint64(l))
	}
	if m.Signature != nil {
		l = len(m.Signature)
		n += 1 + l + sovNetwork(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RemoteRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AppKey != nil {
		l = len(*m.AppKey)
		n += 1 + l + sovNetwork(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RemoteResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Res != nil {
		l = len(m.Res)
		n += 1 + l + sovNetwork(uint64(l))
	}
	if m.Error != nil {
		l = len(*m.Error)
		n += 1 + l + sovNetwork(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RequestCheckModel) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TaskHash != nil {
		l = len(*m.TaskHash)
		n += 1 + l + sovNetwork(uint64(l))
	}
	if m.Name != nil {
		l = len(*m.Name)
		n += 1 + l + sovNetwork(uint64(l))
	}
	if m.Time != nil {
		n += 1 + sovNetwork(uint64(*m.Time))
	}
	if m.Description != nil {
		l = len(*m.Description)
		n += 1 + l + sovNetwork(uint64(l))
	}
	if m.Creator != nil {
		l = len(*m.Creator)
		n += 1 + l + sovNetwork(uint64(l))
	}
	if m.Model != nil {
		l = len(m.Model)
		n += 1 + l + sovNetwork(uint64(l))
	}
	if m.ModelName != nil {
		l = len(m.ModelName)
		n += 1 + l + sovNetwork(uint64(l))
	}
	if m.AppKey != nil {
		l = len(*m.AppKey)
		n += 1 + l + sovNetwork(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RequestCheckModelACK) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != nil {
		n += 1 + sovNetwork(uint64(*m.Code))
	}
	if m.Err != nil {
		l = len(*m.Err)
		n += 1 + l + sovNetwork(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CheckModel) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TaskHash != nil {
		l = len(*m.TaskHash)
		n += 1 + l + sovNetwork(uint64(l))
	}
	if m.ModelHash != nil {
		l = len(*m.ModelHash)
		n += 1 + l + sovNetwork(uint64(l))
	}
	if m.Code != nil {
		n += 1 + sovNetwork(uint64(*m.Code))
	}
	if m.Msg != nil {
		l = len(*m.Msg)
		n += 1 + l + sovNetwork(uint64(l))
	}
	if m.Err != nil {
		l = len(*m.Err)
		n += 1 + l + sovNetwork(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CheckModelACK) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != nil {
		n += 1 + sovNetwork(uint64(*m.Code))
	}
	if m.Err != nil {
		l = len(*m.Err)
		n += 1 + l + sovNetwork(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CancelTask) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TaskHash != nil {
		l = len(*m.TaskHash)
		n += 1 + l + sovNetwork(uint64(l))
	}
	if m.AppKey != nil {
		l = len(*m.AppKey)
		n += 1 + l + sovNetwork(uint64(l))
	}
	if m.ModelHash != nil {
		l = len(*m.ModelHash)
		n += 1 + l + sovNetwork(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CancelTaskACK) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != nil {
		n += 1 + sovNetwork(uint64(*m.Code))
	}
	if m.Err != nil {
		l = len(*m.Err)
		n += 1 + l + sovNetwork(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RequestRunModel) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TaskHash != nil {
		l = len(*m.TaskHash)
		n += 1 + l + sovNetwork(uint64(l))
	}
	if m.ModelHash != nil {
		l = len(*m.ModelHash)
		n += 1 + l + sovNetwork(uint64(l))
	}
	if m.Args != nil {
		l = len(m.Args)
		n += 1 + l + sovNetwork(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RequestRunModelACK) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != nil {
		n += 1 + sovNetwork(uint64(*m.Code))
	}
	if m.Err != nil {
		l = len(*m.Err)
		n += 1 + l + sovNetwork(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ResponseRunModel) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TaskHash != nil {
		l = len(*m.TaskHash)
		n += 1 + l + sovNetwork(uint64(l))
	}
	if m.ModelHash != nil {
		l = len(*m.ModelHash)
		n += 1 + l + sovNetwork(uint64(l))
	}
	if m.Code != nil {
		n += 1 + sovNetwork(uint64(*m.Code))
	}
	if m.Res != nil {
		l = len(m.Res)
		n += 1 + l + sovNetwork(uint64(l))
	}
	if m.Err != nil {
		l = len(*m.Err)
		n += 1 + l + sovNetwork(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ResponseRunModelACK) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != nil {
		n += 1 + sovNetwork(uint64(*m.Code))
	}
	if m.Err != nil {
		l = len(*m.Err)
		n += 1 + l + sovNetwork(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RequestCall) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TaskHash != nil {
		l = len(*m.TaskHash)
		n += 1 + l + sovNetwork(uint64(l))
	}
	if m.AppKey != nil {
		l = len(*m.AppKey)
		n += 1 + l + sovNetwork(uint64(l))
	}
	if m.Method != nil {
		l = len(*m.Method)
		n += 1 + l + sovNetwork(uint64(l))
	}
	if m.Args != nil {
		l = len(m.Args)
		n += 1 + l + sovNetwork(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RequestCallACK) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != nil {
		n += 1 + sovNetwork(uint64(*m.Code))
	}
	if m.Err != nil {
		l = len(*m.Err)
		n += 1 + l + sovNetwork(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ResponseCall) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TaskHash != nil {
		l = len(*m.TaskHash)
		n += 1 + l + sovNetwork(uint64(l))
	}
	if m.AppKey != nil {
		l = len(*m.AppKey)
		n += 1 + l + sovNetwork(uint64(l))
	}
	if m.Code != nil {
		n += 1 + sovNetwork(uint64(*m.Code))
	}
	if m.Res != nil {
		l = len(m.Res)
		n += 1 + l + sovNetwork(uint64(l))
	}
	if m.Err != nil {
		l = len(*m.Err)
		n += 1 + l + sovNetwork(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ResponseCallACK) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != nil {
		n += 1 + sovNetwork(uint64(*m.Code))
	}
	if m.Err != nil {
		l = len(*m.Err)
		n += 1 + l + sovNetwork(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BXMNode) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != nil {
		l = len(*m.Id)
		n += 1 + l + sovNetwork(uint64(l))
	}
	if len(m.Addrs) > 0 {
		for _, s := range m.Addrs {
			l = len(s)
			n += 1 + l + sovNetwork(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BXMNodes) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Gid != nil {
		l = len(*m.Gid)
		n += 1 + l + sovNetwork(uint64(l))
	}
	if len(m.Nodes) > 0 {
		for _, e := range m.Nodes {
			l = e.Size()
			n += 1 + l + sovNetwork(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NodeGroupInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != nil {
		l = len(*m.Id)
		n += 1 + l + sovNetwork(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ResQuery) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Version != nil {
		l = len(*m.Version)
		n += 1 + l + sovNetwork(uint64(l))
	}
	if m.BmID != nil {
		l = len(*m.BmID)
		n += 1 + l + sovNetwork(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ResQueryACK) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Version != nil {
		l = len(*m.Version)
		n += 1 + l + sovNetwork(uint64(l))
	}
	if m.BmID != nil {
		l = len(*m.BmID)
		n += 1 + l + sovNetwork(uint64(l))
	}
	if m.DiskTotalSize != nil {
		n += 1 + sovNetwork(uint64(*m.DiskTotalSize))
	}
	if m.DiskRestSize != nil {
		n += 1 + sovNetwork(uint64(*m.DiskRestSize))
	}
	if m.CpuNum != nil {
		n += 1 + sovNetwork(uint64(*m.CpuNum))
	}
	if m.Memory != nil {
		n += 1 + sovNetwork(uint64(*m.Memory))
	}
	if m.Error != nil {
		l = len(*m.Error)
		n += 1 + l + sovNetwork(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ClusterFilesAdd) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Version != nil {
		l = len(*m.Version)
		n += 1 + l + sovNetwork(uint64(l))
	}
	if m.Did != nil {
		l = len(*m.Did)
		n += 1 + l + sovNetwork(uint64(l))
	}
	if m.Data != nil {
		l = len(m.Data)
		n += 1 + l + sovNetwork(uint64(l))
	}
	if m.Error != nil {
		l = len(*m.Error)
		n += 1 + l + sovNetwork(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ClusterFilesAddACK) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Version != nil {
		l = len(*m.Version)
		n += 1 + l + sovNetwork(uint64(l))
	}
	if m.Error != nil {
		l = len(*m.Error)
		n += 1 + l + sovNetwork(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ClusterFilesTake) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Version != nil {
		l = len(*m.Version)
		n += 1 + l + sovNetwork(uint64(l))
	}
	if m.Did != nil {
		l = len(*m.Did)
		n += 1 + l + sovNetwork(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ClusterFilesTakeACK) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Version != nil {
		l = len(*m.Version)
		n += 1 + l + sovNetwork(uint64(l))
	}
	if m.Did != nil {
		l = len(*m.Did)
		n += 1 + l + sovNetwork(uint64(l))
	}
	if m.Data != nil {
		l = len(m.Data)
		n += 1 + l + sovNetwork(uint64(l))
	}
	if m.Error != nil {
		l = len(*m.Error)
		n += 1 + l + sovNetwork(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ClusterFilesDelete) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Version != nil {
		l = len(*m.Version)
		n += 1 + l + sovNetwork(uint64(l))
	}
	if m.Did != nil {
		l = len(*m.Did)
		n += 1 + l + sovNetwork(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ClusterFilesDeleteACK) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Version != nil {
		l = len(*m.Version)
		n += 1 + l + sovNetwork(uint64(l))
	}
	if m.Did != nil {
		l = len(*m.Did)
		n += 1 + l + sovNetwork(uint64(l))
	}
	if m.Error != nil {
		l = len(*m.Error)
		n += 1 + l + sovNetwork(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FCRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FCID != nil {
		l = len(*m.FCID)
		n += 1 + l + sovNetwork(uint64(l))
	}
	if m.TaskID != nil {
		l = len(*m.TaskID)
		n += 1 + l + sovNetwork(uint64(l))
	}
	if m.Caller != nil {
		l = len(*m.Caller)
		n += 1 + l + sovNetwork(uint64(l))
	}
	if m.VmType != nil {
		n += 1 + sovNetwork(uint64(*m.VmType))
	}
	if m.ExecuteContent != nil {
		l = m.ExecuteContent.Size()
		n += 1 + l + sovNetwork(uint64(l))
	}
	if m.Type != nil {
		n += 1 + sovNetwork(uint64(*m.Type))
	}
	if m.External != nil {
		l = len(m.External)
		n += 1 + l + sovNetwork(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PSAInvokeExternal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ParticipantList) > 0 {
		for k, v := range m.ParticipantList {
			_ = k
			_ = v
			mapEntrySize := 1 + sovNetwork(uint64(k)) + 1 + len(v) + sovNetwork(uint64(len(v)))
			n += mapEntrySize + 1 + sovNetwork(uint64(mapEntrySize))
		}
	}
	if m.Type != nil {
		n += 1 + sovNetwork(uint64(*m.Type))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PSIInvokeExternal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SetSize != nil {
		n += 1 + sovNetwork(uint64(*m.SetSize))
	}
	if m.N != nil {
		l = len(m.N)
		n += 1 + l + sovNetwork(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FCExecuteContent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ModelID != nil {
		l = len(*m.ModelID)
		n += 1 + l + sovNetwork(uint64(l))
	}
	if m.AppKey != nil {
		l = len(*m.AppKey)
		n += 1 + l + sovNetwork(uint64(l))
	}
	if m.Method != nil {
		l = len(*m.Method)
		n += 1 + l + sovNetwork(uint64(l))
	}
	if m.Args != nil {
		l = len(m.Args)
		n += 1 + l + sovNetwork(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FCResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FCID != nil {
		l = len(*m.FCID)
		n += 1 + l + sovNetwork(uint64(l))
	}
	if m.Code != nil {
		n += 1 + sovNetwork(uint64(*m.Code))
	}
	if m.Res != nil {
		l = len(m.Res)
		n += 1 + l + sovNetwork(uint64(l))
	}
	if m.Err != nil {
		l = len(*m.Err)
		n += 1 + l + sovNetwork(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FCIntermediateMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FCID != nil {
		l = len(*m.FCID)
		n += 1 + l + sovNetwork(uint64(l))
	}
	if m.Type != nil {
		n += 1 + sovNetwork(uint64(*m.Type))
	}
	if m.Body != nil {
		l = len(m.Body)
		n += 1 + l + sovNetwork(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PSIMaskRequestBody) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StartNumber != nil {
		n += 1 + sovNetwork(uint64(*m.StartNumber))
	}
	if len(m.SubSet) > 0 {
		for _, b := range m.SubSet {
			l = len(b)
			n += 1 + l + sovNetwork(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PSIMaskResponseInitBody) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RoundNumber != nil {
		n += 1 + sovNetwork(uint64(*m.RoundNumber))
	}
	if m.TableSize != nil {
		n += 1 + sovNetwork(uint64(*m.TableSize))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PSIMaskResponseBody) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Buckets) > 0 {
		for _, e := range m.Buckets {
			l = e.Size()
			n += 1 + l + sovNetwork(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PSIBucket) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Number != nil {
		n += 1 + sovNetwork(uint64(*m.Number))
	}
	if len(m.Set) > 0 {
		for _, e := range m.Set {
			l = e.Size()
			n += 1 + l + sovNetwork(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PSISetData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Index != nil {
		n += 1 + sovNetwork(uint64(*m.Index))
	}
	if m.Data != nil {
		l = len(m.Data)
		n += 1 + l + sovNetwork(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovNetwork(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozNetwork(x uint64) (n int) {
	return sovNetwork(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *FetchData) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetwork
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FetchData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FetchData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetwork
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.AppKey = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Args", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetwork
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthNetwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Args = append(m.Args[:0], dAtA[iNdEx:postIndex]...)
			if m.Args == nil {
				m.Args = []byte{}
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Function", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetwork
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Function = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NRet", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NRet = &v
			hasFields[0] |= uint64(0x00000008)
		default:
			iNdEx = preIndex
			skippy, err := skipNetwork(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetwork
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetwork
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FetchDataACK) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetwork
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FetchDataACK: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FetchDataACK: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Did", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetwork
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Did = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetwork
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthNetwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Length", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Length = &v
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetwork
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Error = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetwork(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetwork
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetwork
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Message) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetwork
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Message: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Message: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var v Message_Type
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= Message_Type(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Type = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Body", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetwork
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthNetwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Body = append(m.Body[:0], dAtA[iNdEx:postIndex]...)
			if m.Body == nil {
				m.Body = []byte{}
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetwork
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthNetwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = append(m.Signature[:0], dAtA[iNdEx:postIndex]...)
			if m.Signature == nil {
				m.Signature = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetwork(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetwork
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetwork
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RemoteRequest) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetwork
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RemoteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RemoteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetwork
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.AppKey = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		default:
			iNdEx = preIndex
			skippy, err := skipNetwork(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetwork
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetwork
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RemoteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetwork
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RemoteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RemoteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Res", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetwork
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthNetwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Res = append(m.Res[:0], dAtA[iNdEx:postIndex]...)
			if m.Res == nil {
				m.Res = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetwork
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Error = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetwork(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetwork
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetwork
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RequestCheckModel) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetwork
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RequestCheckModel: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RequestCheckModel: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaskHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetwork
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.TaskHash = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetwork
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Name = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Time = &v
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetwork
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Description = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000008)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetwork
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Creator = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000010)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Model", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetwork
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthNetwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Model = append(m.Model[:0], dAtA[iNdEx:postIndex]...)
			if m.Model == nil {
				m.Model = []byte{}
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000020)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModelName", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetwork
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthNetwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ModelName = append(m.ModelName[:0], dAtA[iNdEx:postIndex]...)
			if m.ModelName == nil {
				m.ModelName = []byte{}
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000040)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetwork
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.AppKey = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000080)
		default:
			iNdEx = preIndex
			skippy, err := skipNetwork(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetwork
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetwork
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000010) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000020) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000040) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000080) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RequestCheckModelACK) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetwork
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RequestCheckModelACK: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RequestCheckModelACK: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Code = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Err", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetwork
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Err = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetwork(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetwork
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetwork
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CheckModel) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetwork
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheckModel: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheckModel: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaskHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetwork
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.TaskHash = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModelHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetwork
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.ModelHash = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Code = &v
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetwork
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Msg = &s
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Err", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetwork
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Err = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetwork(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetwork
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetwork
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CheckModelACK) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetwork
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheckModelACK: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheckModelACK: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Code = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Err", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetwork
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Err = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetwork(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetwork
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetwork
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CancelTask) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetwork
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CancelTask: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CancelTask: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaskHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetwork
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.TaskHash = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetwork
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.AppKey = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModelHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetwork
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.ModelHash = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetwork(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetwork
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetwork
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CancelTaskACK) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetwork
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CancelTaskACK: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CancelTaskACK: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Code = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Err", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetwork
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Err = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetwork(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetwork
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetwork
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RequestRunModel) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetwork
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RequestRunModel: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RequestRunModel: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaskHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetwork
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.TaskHash = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModelHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetwork
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.ModelHash = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Args", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetwork
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthNetwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Args = append(m.Args[:0], dAtA[iNdEx:postIndex]...)
			if m.Args == nil {
				m.Args = []byte{}
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000004)
		default:
			iNdEx = preIndex
			skippy, err := skipNetwork(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetwork
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetwork
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RequestRunModelACK) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetwork
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RequestRunModelACK: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RequestRunModelACK: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Code = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Err", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetwork
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Err = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetwork(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetwork
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetwork
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResponseRunModel) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetwork
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResponseRunModel: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResponseRunModel: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaskHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetwork
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.TaskHash = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModelHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetwork
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.ModelHash = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Code = &v
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Res", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetwork
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthNetwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Res = append(m.Res[:0], dAtA[iNdEx:postIndex]...)
			if m.Res == nil {
				m.Res = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Err", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetwork
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Err = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetwork(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetwork
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetwork
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResponseRunModelACK) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetwork
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResponseRunModelACK: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResponseRunModelACK: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Code = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Err", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetwork
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Err = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetwork(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetwork
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetwork
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RequestCall) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetwork
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RequestCall: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RequestCall: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaskHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetwork
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.TaskHash = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetwork
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.AppKey = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Method", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetwork
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Method = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Args", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetwork
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthNetwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Args = append(m.Args[:0], dAtA[iNdEx:postIndex]...)
			if m.Args == nil {
				m.Args = []byte{}
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000008)
		default:
			iNdEx = preIndex
			skippy, err := skipNetwork(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetwork
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetwork
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RequestCallACK) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetwork
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RequestCallACK: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RequestCallACK: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Code = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Err", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetwork
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Err = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetwork(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetwork
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetwork
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResponseCall) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetwork
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResponseCall: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResponseCall: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaskHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetwork
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.TaskHash = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetwork
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.AppKey = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Code = &v
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Res", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetwork
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthNetwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Res = append(m.Res[:0], dAtA[iNdEx:postIndex]...)
			if m.Res == nil {
				m.Res = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Err", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetwork
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Err = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetwork(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetwork
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetwork
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResponseCallACK) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetwork
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResponseCallACK: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResponseCallACK: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Code = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Err", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetwork
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Err = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetwork(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetwork
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetwork
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BXMNode) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetwork
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BXMNode: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BXMNode: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetwork
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Id = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addrs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetwork
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addrs = append(m.Addrs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetwork(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetwork
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetwork
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BXMNodes) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetwork
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BXMNodes: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BXMNodes: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetwork
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Gid = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nodes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetwork
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNetwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nodes = append(m.Nodes, &BXMNode{})
			if err := m.Nodes[len(m.Nodes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetwork(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetwork
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetwork
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeGroupInfo) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetwork
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeGroupInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeGroupInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetwork
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Id = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		default:
			iNdEx = preIndex
			skippy, err := skipNetwork(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetwork
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetwork
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResQuery) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetwork
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResQuery: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResQuery: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetwork
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Version = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BmID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetwork
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.BmID = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		default:
			iNdEx = preIndex
			skippy, err := skipNetwork(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetwork
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetwork
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResQueryACK) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetwork
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResQueryACK: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResQueryACK: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetwork
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Version = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BmID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetwork
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.BmID = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiskTotalSize", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DiskTotalSize = &v
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiskRestSize", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DiskRestSize = &v
			hasFields[0] |= uint64(0x00000008)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuNum", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CpuNum = &v
			hasFields[0] |= uint64(0x00000010)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Memory", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Memory = &v
			hasFields[0] |= uint64(0x00000020)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetwork
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Error = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetwork(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetwork
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetwork
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000010) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000020) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClusterFilesAdd) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetwork
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClusterFilesAdd: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClusterFilesAdd: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetwork
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Version = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Did", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetwork
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Did = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetwork
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthNetwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetwork
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Error = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetwork(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetwork
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetwork
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClusterFilesAddACK) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetwork
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClusterFilesAddACK: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClusterFilesAddACK: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetwork
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Version = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetwork
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Error = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetwork(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetwork
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetwork
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClusterFilesTake) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetwork
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClusterFilesTake: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClusterFilesTake: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetwork
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Version = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Did", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetwork
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Did = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		default:
			iNdEx = preIndex
			skippy, err := skipNetwork(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetwork
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetwork
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClusterFilesTakeACK) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetwork
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClusterFilesTakeACK: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClusterFilesTakeACK: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetwork
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Version = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Did", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetwork
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Did = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetwork
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthNetwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetwork
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Error = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetwork(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetwork
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetwork
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClusterFilesDelete) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetwork
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClusterFilesDelete: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClusterFilesDelete: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetwork
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Version = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Did", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetwork
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Did = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		default:
			iNdEx = preIndex
			skippy, err := skipNetwork(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetwork
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetwork
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClusterFilesDeleteACK) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetwork
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClusterFilesDeleteACK: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClusterFilesDeleteACK: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetwork
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Version = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Did", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetwork
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Did = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetwork
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Error = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetwork(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetwork
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetwork
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FCRequest) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetwork
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FCRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FCRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FCID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetwork
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.FCID = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaskID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetwork
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.TaskID = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Caller", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetwork
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Caller = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VmType", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.VmType = &v
			hasFields[0] |= uint64(0x00000008)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExecuteContent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetwork
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNetwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExecuteContent == nil {
				m.ExecuteContent = &FCExecuteContent{}
			}
			if err := m.ExecuteContent.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000010)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var v FCRequest_FCType
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= FCRequest_FCType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Type = &v
			hasFields[0] |= uint64(0x00000020)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field External", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetwork
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthNetwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.External = append(m.External[:0], dAtA[iNdEx:postIndex]...)
			if m.External == nil {
				m.External = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetwork(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetwork
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetwork
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000010) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000020) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PSAInvokeExternal) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetwork
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PSAInvokeExternal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PSAInvokeExternal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParticipantList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetwork
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNetwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ParticipantList == nil {
				m.ParticipantList = make(map[uint32]string)
			}
			var mapkey uint32
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNetwork
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowNetwork
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowNetwork
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthNetwork
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthNetwork
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipNetwork(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthNetwork
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ParticipantList[mapkey] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var v PSAInvokeExternal_PSAType
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= PSAInvokeExternal_PSAType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Type = &v
			hasFields[0] |= uint64(0x00000001)
		default:
			iNdEx = preIndex
			skippy, err := skipNetwork(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetwork
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetwork
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PSIInvokeExternal) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetwork
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PSIInvokeExternal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PSIInvokeExternal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SetSize", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SetSize = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field N", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetwork
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthNetwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.N = append(m.N[:0], dAtA[iNdEx:postIndex]...)
			if m.N == nil {
				m.N = []byte{}
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		default:
			iNdEx = preIndex
			skippy, err := skipNetwork(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetwork
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetwork
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FCExecuteContent) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetwork
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FCExecuteContent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FCExecuteContent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModelID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetwork
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.ModelID = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetwork
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.AppKey = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Method", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetwork
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Method = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Args", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetwork
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthNetwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Args = append(m.Args[:0], dAtA[iNdEx:postIndex]...)
			if m.Args == nil {
				m.Args = []byte{}
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000008)
		default:
			iNdEx = preIndex
			skippy, err := skipNetwork(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetwork
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetwork
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FCResponse) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetwork
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FCResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FCResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FCID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetwork
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.FCID = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Code = &v
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Res", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetwork
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthNetwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Res = append(m.Res[:0], dAtA[iNdEx:postIndex]...)
			if m.Res == nil {
				m.Res = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Err", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetwork
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Err = &s
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetwork(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetwork
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetwork
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FCIntermediateMessage) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetwork
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FCIntermediateMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FCIntermediateMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FCID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNetwork
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNetwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.FCID = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var v FCIntermediateMessage_Type
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= FCIntermediateMessage_Type(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Type = &v
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Body", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetwork
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthNetwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Body = append(m.Body[:0], dAtA[iNdEx:postIndex]...)
			if m.Body == nil {
				m.Body = []byte{}
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000004)
		default:
			iNdEx = preIndex
			skippy, err := skipNetwork(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetwork
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetwork
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PSIMaskRequestBody) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetwork
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PSIMaskRequestBody: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PSIMaskRequestBody: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartNumber", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.StartNumber = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubSet", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetwork
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthNetwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubSet = append(m.SubSet, make([]byte, postIndex-iNdEx))
			copy(m.SubSet[len(m.SubSet)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetwork(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetwork
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetwork
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PSIMaskResponseInitBody) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetwork
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PSIMaskResponseInitBody: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PSIMaskResponseInitBody: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoundNumber", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RoundNumber = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableSize", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TableSize = &v
			hasFields[0] |= uint64(0x00000002)
		default:
			iNdEx = preIndex
			skippy, err := skipNetwork(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetwork
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetwork
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PSIMaskResponseBody) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetwork
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PSIMaskResponseBody: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PSIMaskResponseBody: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Buckets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetwork
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNetwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Buckets = append(m.Buckets, &PSIBucket{})
			if err := m.Buckets[len(m.Buckets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetwork(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetwork
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetwork
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PSIBucket) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetwork
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PSIBucket: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PSIBucket: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Number", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Number = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Set", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNetwork
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNetwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Set = append(m.Set, &PSISetData{})
			if err := m.Set[len(m.Set)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNetwork(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetwork
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetwork
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PSISetData) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNetwork
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PSISetData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PSISetData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Index = &v
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNetwork
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthNetwork
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		default:
			iNdEx = preIndex
			skippy, err := skipNetwork(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNetwork
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNetwork
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return new(github_com_golang_protobuf_proto.RequiredNotSetError)
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipNetwork(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowNetwork
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowNetwork
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthNetwork
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupNetwork
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthNetwork
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthNetwork        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowNetwork          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupNetwork = fmt.Errorf("proto: unexpected end of group")
)
